---
title: What's new in Riverpod 3.0
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import { AutoSnippet } from "/src/components/CodeSnippet";


Welcome to Riverpod 3.0!  
This update includes many long-due features, bug fixes, and simplifications of the API.

This version is a transition period toward a simpler, unified Riverpod.  

:::caution
This version contains a few life-cycle changes. Those could break your app in subtle ways. Upgrade carefully.  
For the migration guide, please refer to the [migration page](3.0_migration).
:::

Some of the key highlights include:

- [Offline persistence (experimental)](#offline-persistence-experimental) - Providers can now opt-in to be persisted to a database
- [Mutations (experimental) (code-generation)](#mutations-experimental-code-generation-only) - A new mechanism to enable interfaces to react to side-effects
- [Automatic retry](#automatic-retry) - Providers now refresh when they fail, with exponential backoff
- [`Ref.mounted`](#refmounted) - Similar to `BuildContext.mounted`, but for `Ref`.
- [Generic support (code-generation)](#generic-support-code-generation) - Generated providers can now define type parameters
- [Pause/Resume support](#pauseresume-support) - Temporarily pause a listener when using `ref.listen`
- [Unification of the Public APIs](#unification-of-the-public-apis) - Behaviors are unified and duplicate interfaces are fused
- [Provider life-cycle changes](#provider-life-cycle-changes) - Slight tweaks to how providers behave, to better fit modern code
- [New testing utilities](#new-testing-utilities):
  - [`ProviderContainer.test`](#providercontainertest) - A test util that creates a container and automatically disposes it after the test ends.
  - [`NotifierProvider.overrideWithBuild`](#notifierprovideroverridewithbuild) - A way to mock only `Notifier.build`, without mocking the whole notifier.
  - [`Future/StreamProvider.overrideWithValue`](#futurestreamprovideroverridewithvalue) - The old utilities are back
- [Statically safe scoping](#statically-safe-scoping-code-generation-only) - New lint rules are added to detect when an override is missing

## Offline persistence (experimental)

:::info
This feature is experimental and not yet stable.
It is usable, but the API may change in breaking ways without a major version bump.
:::

Offline persistence is a new feature that enables caching a provider locally on the device.
Then, when the application is closed and reopened, the provider can be restored from the cache.  
Offline persistence is opt-in, and supported by all "Notifier" providers,
and regardless of if you use code generation or not.

Riverpod only includes interfaces to interact with a database. It does not include a database itself.
You can use any database you want, as long as it implements the interfaces.  
An official package for SQlife is maintained: [riverpod_sqflite](https://pub.dev/packages/riverpod_sqflite).


<AutoSnippet language="dart" raw="void main() {}"></AutoSnippet>

{/*  TODO  */}

## Mutations (experimental) (code-generation only)

:::info
This feature is experimental and not yet stable.
It is usable, but the API may change in breaking ways without a major version bump.
:::


{/*  TODO  */}

## Automatic retry

Starting 3.0, providers that fail during initialization will automatically retry.
The retry is done with an exponential backoff, and the provider will be retried
until it succeeds or is disposed. This helps when an operation fails due to a temporary issue, such as a lack of network connection.

The default behavior retries any error, and starts with a 200ms delay that
doubles after each retry up to 6.4 seconds.  
This can be customized for all providers on [ProviderContainer]/[ProviderScope] by passing a `retry` parameter:

<Tabs>
<TabItem value="ProviderScope" label="ProviderScope" defaultValue>

```dart
void main() {
  runApp(
    ProviderScope(
      // You can customize the retry logic, such as to skip
      // specific errors or add a limit to the number of retries
      // or change the delay
      retry: (retryCount, error) {
        if (error is SomeSpecificError) return null;
        if (retryCount > 5) return null;

        return Duration(seconds: retryCount * 2);
      },
      child: MyApp(),
    ),
  );
}
```

</TabItem>
<TabItem value="ProviderContainer" label="ProviderContainer" defaultValue>

```dart
void main() {
  final container = ProviderContainer(
    // You can customize the retry logic, such as to skip
    // specific errors or add a limit to the number of retries
    // or change the delay
    retry: (retryCount, error) {
      if (error is SomeSpecificError) return null;
      if (retryCount > 5) return null;

      return Duration(seconds: retryCount * 2);
    },
  );
}
```

</TabItem>
</Tabs>

Alternatively, this can be configured on a per-provider basis by passing a `retry` parameter to the provider constructor:

<AutoSnippet
  language="dart"
  codegen={`
  Duration retry(int retryCount, Object error) {
    if (error is SomeSpecificError) return null;
    if (retryCount > 5) return null;
  
    return Duration(seconds: retryCount * 2);
  }
  
  @Riverpod(retry: retry)
  class TodoList extends _$TodoList {
    @override
    List<Todo> build() => [];
  }
  `}
  
  raw={`
  final todoListProvider = NotifierProvider<TodoList, List<Todo>>(
    TodoList.new,
    retry: (retryCount, error) {
      if (error is SomeSpecificError) return null;
      if (retryCount > 5) return null;
    
      return Duration(seconds: retryCount * 2);
    },
  );
  `}
></AutoSnippet>


## `Ref.mounted`

The long-awaited `Ref.mounted` is finally here! It is similar to `BuildContext.mounted`, but for `Ref`.

You can use it to check if a provider is still mounted after an async operation:

<AutoSnippet
  language="dart"
  codegen={`
  @riverpod
  class TodoList extends _$TodoList {
    @override
    List<Todo> build() => [];
    
    Future<void> addTodo(String title) async {
      // Post the new todo to the server
      final newTodo = await api.addTodo(title);
      // Check if the provider is still mounted
      // after the async operation
      if (!ref.mounted) return;
    
      // If it is, update the state
      state = [...state, newTodo];
    }
  }
  `}
  
  raw={`
  class TodoList extends Notifier<List<Todo>> {
    @override
    List<Todo> build() => [];
    
    Future<void> addTodo(String title) async {
      // Post the new todo to the server
      final newTodo = await api.addTodo(title);
      // Check if the provider is still mounted
      // after the async operation
      if (!ref.mounted) return;
    
      // If it is, update the state
      state = [...state, newTodo];
    }
  }
  `}
></AutoSnippet>

For this to work, quite a few life-cycle changes were necessary.  
Make sure to read the [life-cycle changes](#provider-life-cycle-changes) section.

## Generic support (code-generation)

When using code generation, you can now define type parameters for your generated providers.
Type parameters work like any other provider parameter, and need to be passed
when watching the provider.

```dart
@riverpod
T multiply<T extends num>(T a, T b) {
  return a * b;
}

// ...

int integer = ref.watch(multiplyProvider<int>(2, 3));
double decimal = ref.watch(multiplyProvider<double>(2.5, 3.5));
```

## Pause/Resume support

In 2.0, Riverpod already had some form of pause/resume support, but it was fairly limited.
With 3.0, all `ref.listen` listeners can be manually paused/resumed on demand:

```dart
final subscription = ref.listen(
  todoListProvider,
  (previous, next) {
    // Do something with the new value
  },
);

subscription.pause();
subscription.resume();
```

At the same time, Riverpod now pauses providers in various situations:
- When a provider is no-longer visible, it is paused
  (Based off [Visibility](https://api.flutter.dev/flutter/widgets/Visibility-class.html)).
- When a provider rebuilds, its subscriptions are paused until the rebuild completes.
- When a provider is paused, all of its subscriptions are paused too.

See the [life-cycle changes](#provider-life-cycle-changes) section for more details.

## Unification of the Public APIs

One goal of Riverpod 3.0 is to simplify the API. This includes:
- Highlighting what ha recommended and what is not
- Removing needless interface duplicates
- Making sure all functionalities function in a consistent way

For this sake, a few changes were made:

### [StateProvider]/[StateNotifierProvider] and [ChangeNotifierProvider] are discouraged and moved to a different import

Those providers are not removed, but simply moved to a different import.
Instead of:

```dart
import 'package:riverpod/riverpod.dart';
```
You should now use:
```dart
import 'package:riverpod/legacy.dart';
```

This is to highlight that those providers are not recommended anymore.  
At the same time, those are preserved for backward compatibility.

### AutoDispose interfaces are removed

No, the "auto-dispose" feature isn't removed. This only concerns the interfaces.
In 2.0, every provider, Ref, and Notifier was duplicated for the sake of auto-dispose (
`Ref` vs `AutoDisposeRef`, `Notifier` vs `AutoDisposeNotifier`, etc).
This was done for the sake of having a compilation error in some edge-cases, but came
at the cost of a worse API.

In 3.0, the interfaces are unified, and the previous compilation error is now implemented
as a lint rule (using [riverpod_lint]). 
What this means concretely is that you can replace all references to
`AutoDisposeNotifier` with `Notifier`. The behavior of your code should not change.

```diff
final provider = NotifierProvider.autoDispose<MyNotifier, int>(
  MyNotifier.new,
);

- class MyNotifier extends AutoDisposeNotifier<int> {
+ class MyNotifier extends Notifier<int> {
}
```

### One `Ref` to rule them all

In Riverpod 2.0, each provider came with its own [Ref] subclass (`FutureProviderRef`, `StreamProviderRef`, etc).  
Some `Ref` had `state` property, some a `future`, or a `notifier`, etc. 
Although useful, this was a lot of complexity for not much gain. One of the reasons
for that is because [Notifier]s already have the extra properties it had,
so the interfaces were redundant.

In 3.0, `Ref` is unified. No more generic parameter such as `Ref<T>`,
no more `FutureProviderRef`. We only have one thing: `Ref`.
What this means in practice is, the syntax for generated providers is simplified:

```diff
-Example example(ExampleRef ref) {
+Example example(Ref ref) {
  return Example();
}
```


:::info
This does not concern [WidgetRef], which is intact.  
[Ref] and [WidgetRef] are two different things.
:::

### All `updateShouldNotify` now use `==`

`updateShouldNotify` is a method that is used to determine if a provider should
notify its listeners when a state change occurs. 
But in 2.0, the implementation of this method varied quite a bit between providers.
Some providers used `==`, some `identical`, and some more complex logic.

Starting 3.0, all providers use `==` to filter notifications.

This can impact you in a few ways:
- Some of your providers may not notify their listeners anymore
  in certain situations.
- Some listeners may be notified more often than before.
- If you have a large data class that overrides `==`, you may see a small
  performance impact.

If you are impacted by those changes, you can override `updateShouldNotify` to
use a custom implementation:

<AutoSnippet
  language="dart"
  codegen={`
  @riverpod
  class TodoList extends _$TodoList {
    @override
    List<Todo> build() => [];
  
    @override
    bool updateShouldNotify(List<Todo> previous, List<Todo> next) {
      // Custom implementation
      return true;
    }
  }
  `}
  
  raw={`
  class TodoList extends Notifier<List<Todo>> {
    @override
    List<Todo> build() => [];
  
    @override
    bool updateShouldNotify(List<Todo> previous, List<Todo> next) {
      // Custom implementation
      return true;
    }
  }
  `}
></AutoSnippet>

## Provider life-cycle changes

{/*  TODO  */}
Life-cycle changes

### Listeners inside widgets that are not visible are now paused

Now that Riverpod has a way to [pause listeners](#pauseresume-support), Riverpod uses that to
natively pauses listeners when the widget is not visible. In practice what this means is: Providers that are not used by the visible widget tree
are paused.

As a concrete example, consider an application with two routes:
- A home page, listening to a websocket using a provider
- A settings page, which does not rely on that websocket


In typical applications, a user first opens the home page _and then_ opens the settings page.
This means that while the settings page is open, the homepage is also open, but not visible.

In 2.0, the homepage would actively keep listening to the websocket.  
In 3.0, the websocket provider will instead be paused, possibly saving resources.

**How it works:**  
Riverpod relies on [Visibility] to determine if a widget is visible or not. And when
false, all listeners of a [Consumer] are paused.

It also means that you can rely on [Visibility] yourself to manually control
the pause behavior of your consumers. You can voluntarily set the value to true/false
to forcibly resume/pause listeners:

```dart
class MyWidget extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Visibility(
      visible: false, // This will pause the listeners
      child: Consumer(
        builder: (context, ref, child) {
          // This "watch" will be paused
          // until Visibility is set to true
          final value = ref.watch(myProvider);
          return Text(value.toString());
        },
      ),
    );
  }
}
```

### Notifiers are now recreated when the provider rebuilds.

In 2.0, a [Notifier] instance was maintained for the whole lifetime of a provider.

Although useful, this directly conflicted with the implementation of `Ref.mounted`.


- If a provider A is exclusively used by a provider B, and B is paused, then A is paused too.
- When a provider rebuilds, its previous subscriptions are
  kept until the rebuild completes (but subscriptions are paused)
- UpdateShouldNotify changes
- A new Ref is recreated whenever the provider rebuilds.
- ^ Same with Notifier
- Providers that are not visible are now paused


## New testing utilities

### `ProviderContainer.test`

In 2.0, typical testing code would rely on a custom-made utility called `createContainer`.  
In 3.0, this utility is now part of Riverpod, and is called `ProviderContainer.test`.
It creates a new container, and automatically disposes it after the test ends.

```dart
void main() {
  test('My test', () {
    final container = ProviderContainer.test();
    // Use the container
    // ...
    // The container is automatically disposed after the test ends
  });
}
```

You can safely do a global search-and-replace for `createContainer` to `ProviderContainer.test`.

### `NotifierProvider.overrideWithBuild`

It is now possible to mock only the `Notifier.build` method, without mocking the whole notifier.
This is useful when you want to initialize your notifier with a specific state, but still want to
use the original implementation of the notifier.

<AutoSnippet
  language="dart"
  codegen={`
    @riverpod
    class MyNotifier extends _$MyNotifier {
      @override
      int build() => 0;
    
      void increment() {
        state++;
      }
    }
    
    void main() {
      final container = ProviderContainer.test(
        overrides: [
          myNotifierProvider.overrideWithBuild((ref) {
            // Mock the build method to start at 42.
            // The "increment" method is unaffected.
            return 42;
          }),
        ],
      );
    }
  `}
  
  raw={`
    class MyNotifier extends Notifier<int> {
      @override
      int build() => 0;
    
      void increment() {
        state++;
      }
    }
    
    final myNotifierProvider = NotifierProvider<MyNotifier, int>(MyNotifier.new);
    
    void main() {
      final container = ProviderContainer.test(
        overrides: [
          myNotifierProvider.overrideWithBuild((ref) {
            // Mock the build method to start at 42.
            // The "increment" method is unaffected.
            return 42;
          }),
        ],
      );
    }
  `}
></AutoSnippet>

### `Future/StreamProvider.overrideWithValue`

A while back, `FutureProvider.overrideWithValue` and `StreamProvider.overrideWithValue`
were removed "temporarily" from Riverpod.  
They are finally back!

<AutoSnippet
  language="dart"
  codegen={`
    @riverpod
    Future<int> myFutureProvider() async {
      return 42;
    }
    
    void main() {
      final container = ProviderContainer.test(
        overrides: [
          // Initializes the provider with a value.
          // Changing the override will update the value.
          myFutureProvider.overrideWithValue(AsyncValue.data(42)),
        ],
      );
    }
  `}
  
  raw={`
    Future<int> myFutureProvider() async {
      return 42;
    }
    
    void main() {
      final container = ProviderContainer.test(
        overrides: [
          // Initializes the provider with a value.
          // Changing the override will update the value.
          myFutureProvider.overrideWithValue(AsyncValue.data(42)),
        ],
      );
    }
  `}
></AutoSnippet>

## Statically safe scoping (code-generation only)

Through [riverpod_lint], Riverpod now includes a way to detect when scoping is used incorrectly.
This lints detects when an override is missing, to avoid runtime errors.

Consider:

```dart
// A typical "scoped provider"
@Riverpod(dependencies: [])
Future<int> myFutureProvider() => throw UnimplementedError();
```

To use this provider, you have two options.  
If neither of the following options are used, the provider will throw an error at runtime.

- Override the provider using `ProviderScope` before using it:
  ```dart
  class MyWidget extends StatelessWidget {
    @override
    Widget build(BuildContext context) {
      return ProviderScope(
        overrides: [
          myFutureProvider.overrideWithValue(AsyncValue.data(42)),
        ],
        // A consumer is necessary to access the overridden provider
        child: Consumer(
          builder: (context, ref, child) {
            // Use the provider
            final value = ref.watch(myFutureProvider);
            return Text(value.toString());
          },
        ),
      );
    }
  }
  ```
- Specify `@Dependencies` on whatever uses the scoped provider to indicate that it 
  depends on it.
  ```dart
  @Dependencies([myFuture])
  class MyWidget extends ConsumerWidget {
    @override
    Widget build(BuildContext context, WidgetRef ref) {
      // Use the provider
      final value = ref.watch(myFutureProvider);
      return Text(value.toString());
    }
  }
  ```
  After specifying `@Dependencies`, all usages of `MyWidget` will
  require the same two options as above:
  - Either override the provider using `ProviderScope` before using `MyWidget`
    ```dart
    void main() {
      runApp(
        ProviderScope(
          overrides: [
            myFutureProvider.overrideWithValue(AsyncValue.data(42)),
          ],
          child: MyWidget(),
        ),
      );
    }
    ```
  - Or specify `@Dependencies` on whatever uses `MyWidget` to indicate that it depends on it.
    ```dart
    @Dependencies([myFuture])
    class MyApp extends ConsumerWidget {
      @override
      Widget build(BuildContext context, WidgetRef ref) {
         // MyApp indirectly uses scoped providers through MyWidget
         return MyWidget();
      }
    }
    ```

## Other changes changes

### AsyncValue

[AsyncValue] received various changes.

* It is now "sealed". This enables exhaustive pattern matching:
  ```dart
  AsyncValue<int> value;
  switch (value) {
    case AsyncData():
      print('data');
    case AsyncError():
      print('error');
    case AsyncLoading():
      print('loading');
    // No default case needed
  }
  ```

* `valueOrNull` has been renamed to `value`.
  The old `value` is removed, as its behavior related to errors
  was odd.
  To migrate, do a global search-and-replace of `valueOrNull` -> `value`.

* `AsyncValue.isFromCache` has been added.  
  This flag is set when a value is obtained through offline persistence.
  It enables your UI to differentiate state coming from the database
  and state from the server.

* An optional `progress` property is available on `AsyncLoading`.
  This enables your providers to define the current progress for a
  request:
  
  <AutoSnippet
    language="dart"
    codegen={`
      @riverpod
      class MyNotifier extends _$MyNotifier {
        @override
        Future<User> build() async {
          // You can optionally pass a "progress" to AsyncLoading
          state = AsyncLoading(progress: .0);
          await fetchSomething();
          state = AsyncLoading(progress: 0.5);
          
          return User();
        }
      }
    `}
    
    raw={`
      class MyNotifier extends AsyncNotifier<User> {
        @override
        Future<User> build() async {
          // You can optionally pass a "progress" to AsyncLoading
          state = AsyncLoading(progress: .0);
          await fetchSomething();
          state = AsyncLoading(progress: 0.5);
        
          return User();
        }
      }
    `}
  ></AutoSnippet>

### All Ref listeners now return a way to remove the listener

It is now possible to "unsubscribe" to the various life-cycles listeners:

<AutoSnippet
  language="dart"
  codegen={`
    @riverpod
    Future<int> example(Ref ref) {
      // onDispose and other life-cycle listeners return a function
      // to remove the listener.
      final removeListener = ref.onDispose(() => print('dispose));
      // Simply call the function to remove the listener:
      removeListener();
      
      // ...
    }
  `}
  
  raw={`
    final exampleProvider = FutureProvider<int>((ref) {
      // onDispose and other life-cycle listeners return a function
      // to remove the listener.
      final removeListener = ref.onDispose(() => print('dispose));
      // Simply call the function to remove the listener:
      removeListener();
       
      // ...
    });
  `}
></AutoSnippet>

### Weak listeners - listen to a provider without preventing auto-dispose.

When using `Ref.listen`, you can optionally specify `weak: true`:

<AutoSnippet
  language="dart"
  codegen={`
    @riverpod
    Future<int> example(Ref ref) {
      ref.listen(
        anotherProvider,
        // Specify the flag
        weak: true,
        (previous, next) {},
      );
      
      // ...
    }
  `}
  
  raw={`
    final exampleProvider = FutureProvider<int>((ref) {
      ref.listen(
        anotherProvider,
        // Specify the flag
        weak: true,
        (previous, next) {},
      );
      
      // ...
    });
  `}
></AutoSnippet>

Specifying this flag will tell Riverpod that it can still dispose
the listened provider if it stops being used.

This flag is an advanced feature to help with some niche use-cases
regarding combining multiple "sources of truth" in a single provider.

[ProviderContainer]: https://pub.dev/documentation/flutter_riverpod/latest/flutter_riverpod/ProviderContainer-class.html
[ProviderScope]: https://pub.dev/documentation/flutter_riverpod/latest/flutter_riverpod/ProviderScope-class.html
[riverpod_lint]: https://pub.dev/packages/riverpod_lint
[Ref]: https://pub.dev/documentation/flutter_riverpod/latest/flutter_riverpod/Ref-class.html
[WidgetRef]: https://pub.dev/documentation/flutter_riverpod/latest/flutter_riverpod/WidgetRef-class.html
[Visibility]: https://api.flutter.dev/flutter/widgets/Visibility-class.html
[Consumer]: https://pub.dev/documentation/flutter_riverpod/latest/flutter_riverpod/Consumer-class.html
[Notifier]: https://pub.dev/documentation/flutter_riverpod/latest/flutter_riverpod/Notifier-class.html