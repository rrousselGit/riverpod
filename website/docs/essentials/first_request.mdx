---
title: Make your first network request (WIP)
version: 1
---

import { Link } from "../../src/components/Link";
import { AutoSnippet } from "../../src/components/CodeSnippet";
import model from "./first_request/model";
import Legend from "./first_request/legend/legend";

:::note
This page is a work in progress
:::

Network requests are the core of any application. But there are a lot of things to consider when
making a network request:

- The UI should render a loading state while the request is being made
- Errors should be gracefully handled
- The request should be cached if possible

In this section, we will see how Riverpod can help us deal with all of this naturally.

## Setting up `ProviderScope`

Before we start making network requests, we need to make sure that `ProviderScope` is added at the
root of the application.

```dart
void main() {
  runApp(
    // To install Riverpod, we need to add this widget above everything else.
    // This should not be inside "MyApp" but as direct parameter to "runApp".
    ProviderScope(
      child: MyApp(),
    ),
  );
}
```

This is a necessary step to enable Riverpod in your project.

:::note
For complete installation steps (such as installing [riverpod_lint](https://pub.dev/packages/riverpod_lint)
and running the code-generator), check out <Link documentID="introduction/getting_started" />.
:::

## Performing your network request in a "provider"

Performing a network request is usually what we call "business logic".
In Riverpod, business logic is placed inside "providers".  
A provider is a super-powered function.
They behave like normal functions, with the added benefits of:

- being cached
- offering default error/loading handling
- being listenable
- automatically re-executing when some data changes

This make providers a perfect fit for _GET_ network requests (as for _POST/etc_ requests, see <Link documentID="essentials/side_effects" />).

As an example, let's make a simple application which suggests a random activity to do when bored.  
To do so, we will use the [Bored API](https://www.boredapi.com/). In particular,
we will perform a _GET_ request on the `/api/activity` endpoint. This returns a JSON object,
which we will parse into a Dart class instance.  
The next step would then be to display this activity in the UI. We would also make sure
to render a loading state while the request is being made, and to gracefully handle errors.

Sounds great? Let's do it!

### Defining the model

Before we start, we need to define the model of the data we will receive from the API.
This model will also need a way to parse the JSON object into a Dart class instance.

Generally, it is recommended to use a code-generator such as [Freezed](https://pub.dev/packages/freezed)
or [json_serializable](https://pub.dev/packages/json_serializable) to handle
JSON decoding. But of course, it's also possible to do it by hand.

Anyway, here's our model:

<AutoSnippet {...model} />

### Creating the provider

Now that we have our model, we can start querying the API.  
To do so, we will need to create our first provider.

The syntax for defining a provider is as followed:

<Legend
  title="activity.dart"
  annotations={[
    {
      offset: 6,
      length: 8,
      color: "red",
      description:
        "The provider name. This will be used later to access our network request.",
    },
    {
      offset: 17,
      length: 14,
      color: "blue",
      description:
        "The type of provider (Provider, FutureProvider, StreamProvider, ...). The type of provider used depends on the return value of your function. For example, if your function return a Future, then you'll want a FutureProvider; whereas if it returns a Stream, you'll want a StreamProvider.",
    },
    {
      offset: 43,
      length: 3,
      color: "yellow",
      description: "An object used to interact with other providers.",
    },
  ]}
>
  {`final provider = FutureProvider<Activity>((ref) async {
  <your logic here>
});
`}
</Legend>

// TODO mentions that, although Riverpod has many providers, FutureProvider is the main one you should care about

In our case, we want to return a `Future<Actvitiy>`.

```dart
final boredApiProvider = FutureProvider.autoDispose((ref) async {
  final response = await http.get(Uri.parse('https://www.boredapi.com/api/activity'));
  return Activity.fromJson(json.decode(response.body));
});
```

TODO:

- [x] Make sure `ProviderScope` is added at the root of the application
  - Do not add it to `MaterialApp`, but straight up as parameter to `runApp`
- [ ] Define a `FutureProvider`
  - This could fetch the bored API to return a random activity
- [ ] Consume the `FutureProvider` inside a Consumer
- [ ] Handle Loading/Error states
- [ ] Mention how the `FutureProvider` is cached by default

Going further: Making a Repository

- [ ] Cross-link to the Combining request page
- [ ] Mention how making a repository can be useful for testing
      to mock all requests in a single place
- [ ] Mention that making a repository can also be useful for
      deduplicating requests (e.g. to not fetch `/books/:id` if a given ID was already fetched in `/books`)
- [ ] Mention that making a repository is otherwise not that useful,
      as Riverpod already offers a way to mock
