---
title: Provider's limitations
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import CodeBlock from "@theme/CodeBlock";
import sameType from "./same_type";
import combine from "./combine";
import asyncValues from "./async_values";
import autoDispose from "./auto_dispose";
import override from "./override";
import sideEffects from "./side_effects";
import { AutoSnippet } from "../../../src/components/CodeSnippet";



Provider has fundamental issues due to being restricted by the InheritedWidget API.  
Inherently, Provider is a "simpler `InheritedWidget`", or, in other words, 
Provider is merely an InheritedWidget wrapper, and thus it's limited by it.

Here's a list of known Provider issues.

### Provider can't keep two (or more) providers of the same "type"
Declaring two `Provider<int>` will result into unreliable behavior: `InheritedWidget`'s API will 
obtain only one of the two: the closest `Provider<int>` ancestor.  
While a [workaround] is explained in Provider's 
documentation, Riverpod simply doesn't have this problem.

By removing this limitation, we can freely split logic into tiny pieces, like so:

<AutoSnippet language="dart" {...sameType}></AutoSnippet>


### Providers reasonably emit only one value at a time
When reading an external RESTful API, it's quite common to show 
the last read value, while a new requested call loads the next one.  
Riverpod allows this behavior via emitting two values at a time (i.e. a previous data value, 
and an incoming new loading value), via `AsyncValue`'s APIs:

<AutoSnippet language="dart" {...asyncValues}></AutoSnippet>

In the previous snippet, anyone watching `evenOnlyItemsProvider` will obtain the following behavior:
1. Initially, the request is being made. We obtain an empty list;
2. Then, say an error occurs. We obtain the default value defined there;
3. Then, we retry the request with a pull-to-refresh logic (via `ref.invalidate`);
4. While we reload the provider, *the default "error" value is being kept*. At this moment in time, two values cohexist within a single `AsyncValue`;
5. This time, some parsed data is received correctly: even items only are correctly returned.

With Provider, the above features aren't remotely achievable, and even less easy to workaround.

### Combining providers is hard and error prone
With Provider we may be tempted to use `context.watch` inside provider's `create`.  
This would be unreliable, as `didChangeDependencies` may be triggered even if no dependency 
has changed (e.g. such as when there's a GlobalKey involved in the widget tree).

Nonetheless, Provider has an ad-hoc solution named `ProxyProvider`, but it's considered tedious and error-prone.  
Instead, combining state is a core Riverpod mechanism, as we can combine and cache values reactively with zero overhead 
with simple yet powerful utilites such as [ref.watch] and [ref.listen]:

<AutoSnippet language="dart" {...combine}></AutoSnippet>

Combining values feels natural with Riverpod: dependencies are readable and 
there's no different syntax or API to handle this common use case.


### Lack of safety
It's common to end-up with a `ProviderNotFoundException` during refactors and / or during large changes.  
Indeed, this runtime exception *was* one of the main reasons Riverpod was created in the first place.  
Although Riverpod brings much more utility than this, this exception simply can't be thrown.

### Disposing of state is difficult
`InheritedWidget` [*can't* react when a consumer stops listening to them].  
This prevents the ability for Provider 
to automatically destroy its providers' state when they're no-longer used.  
With Provider, [we have to] rely on scoping providers to dispose the state when it stops being used.  
But this isn't easy, as it gets tricky when state is shared between pages.

Riverpod solves this with easy-to-understand APIs such as [autodispose] and [keepAlive]:

<AutoSnippet language="dart" {...autoDispose}></AutoSnippet>


Furthermore, these two APIs enable flexible and creative caching strategies (e.g. time-based caching).  
Unluckily, there's no way to implement this with a raw `InheritedWidget`, and thus with Provider.

### Lack of a reliable parametrization mechanism
Riverpod allows its user to declare "parametrized" Providers with the [.family modifier].  
Indeed, `.family` is one of Riverpod's most powerful feature and it is core to its innovations, 
e.g. it enables enormous [simplification of logic]. 

If we wanted to implement something similar using Provider, we would have to give 
up easiness of use *and* type-safeness on such parameters. 

Furthermore, not being able to implement a similar `.autoDispose` mechanism with Provider 
inherently prevents any equivalent implementation of `.family`, [as these two features go hand-in-hand].

Finally, as shown before, [it turns out] that widgets *never* stop to listen to an `InheritedWidget`.  
This implies significant memory leaks if some provider state is "dynamically mounted", i.e. when using parameters 
to a build a Provider, which is exactly what `.family` does.  
Thus, obtaining a `.family` equivalent for Provider is fundamentally impossible at the moment in time.

### Testing is tedious
To be able to write a test, you *have to* re-define providers inside each test.

With Riverpod, providers are ready to use inside tests, by default. Furthermore, Riverpod exposes a 
handy collection of "overriding" utilites that are crucial when mocking Providers.

Testing the combined state snippet above would be as simple as the following:

<AutoSnippet language="dart" {...override}></AutoSnippet>

For more info about testing, see [Testing].


### Triggering side effects isn't straightforward
Since `InheritedWidget` has no `onChange` callback, Provider can't have one.  
This is problematic for navigation, such as for snackbars, modals, etc.  

Instead, Riverpod simply offers `ref.listen`, which [integrates well with Flutter].

<AutoSnippet language="dart" {...sideEffects}></AutoSnippet>


[ref.watch]: /docs/concepts/reading#using-refwatch-to-observe-a-provider
[ref.listen]: /docs/concepts/reading#using-reflisten-to-react-to-a-provider-change
[autodispose]: /docs/concepts/modifiers/auto_dispose
[workaround]: https://pub.dev/packages/provider#can-i-obtain-two-different-providers-using-the-same-type
[.family modifier]: /docs/concepts/modifiers/family
[keepAlive]: /docs/concepts/modifiers/auto_dispose#refkeepalive
[as these two features go hand-in-hand]: /docs/concepts/modifiers/family#prefer-using-autodispose-when-the-parameter-is-not-constant
[simplification of logic]: /docs/concepts/modifiers/family#usage
[we have to]: https://github.com/flutter/flutter/issues/128432
[it turns out]: https://github.com/flutter/flutter/issues/106549
[*can't* react when a consumer stops listening to them]: https://github.com/flutter/flutter/issues/106546
[Testing]: /docs/cookbooks/testing
[integrates well with Flutter]: /docs/concepts/reading#using-reflisten-to-react-to-a-provider-change
