---
title: Scopes
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

Scoping in Riverpod is an important thing to understand.

Many issues that developers have with Riverpod come from misunderstanding scope.

## Container Scope

A scope is introduced by a `ProviderContainer`. This container holds the current state of
all of your providers. It manages the lookup and subscriptions between providers.

In Flutter you should use the `ProviderScope` widget, which contains a `ProviderContainer`
internally, and provides a way to access that container to the rest of the widget tree.

```dart
final valueProvider = StateProvider((ref) => 0);

// DO this
void main() {
  runApp(ProviderScope(child: MyApp()));
}

//DON'T do this:
final myProviderContainer = ProviderContainer();
void main(){
  runApp(MyApp());
}
```

:::warning
Do not use multiple `ProviderContainers`. Each will have it's own separate thread of states, which will not be able to access each other.
You will quickly become disoriented and confused.
:::

A `ProviderContainer` by itself should only be utilized for testing and dart-only usage.
In Flutter it should not be used, unless you have a need for asynchronous initialization prior
to showing any screens. For asynchronous concerns see the [asynchronous cookbook](/docs/cookbooks/asynchrony)

When a widget or Provider requests the value of a Provider Riverpod finds it in the nearest [ProviderScope] or
if not already available creates it in the root [ProviderScope].

## Scoping Providers to a Widget Subtree

All providers can be scoped to a widget subtree. However, there are some things to keep in mind while doing so.

The easiest way to understand subtree scoping is to go through the todo list example

```dart
/// A simple Todo class
class Todo {
  Todo(this.todo);
  final String todo;
}

/// Provides a list of [Todo]s.
final todoListProvider = StateProvider<List<Todo>>(
    (ref) => [Todo('this'), Todo('that'), Todo('the other')]);

/// Provides the index for a todo in a particular portion
/// of the widget tree
final todoItemIndexProvider = Provider<int>((ref) =>
    throw UnimplementedError('Todo index not set'));

/// Widget for the whole todo list
class TodoListWidget extends ConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final length = ref.watch(todoListProvider.select((list) => list.length));
    print('Build List');
    return ListView.builder(
      itemCount: length,
      itemBuilder: (context, index) {
        // Overrides the todoItemIndexProvider
        // for everything below this in the tree
        return ProviderScope(
          overrides: [
            todoItemIndexProvider.overrideWithValue(index),
          ],
          // Using this approach, TodoWidget can now be constant
          // since no index needs to be passed down
          child: const TodoWidget(),
        );
      },
    );
  }
}

/// Provides a single todo, so you can watch them individually
///
/// This way you will only be notified if the particular todo you
/// were watching was updated
final todoProvider = Provider.family<Todo, int>(
    (ref, index) => ref.watch(todoListProvider).state[index]);

/// A widget to show a single todo
class TodoWidget extends ConsumerWidget {
  const TodoWidget();
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // Gets the index of this particular Todo
    final index = ref.watch(todoItemIndexProvider);
    print('Building Item $index');
    // Watches a single todo item
    final todoItem = ref.watch(todoProvider(index));
    // Display it!
    return Text(todoItem.todo);
  }
}

void main() {
  runApp(
    ProviderScope(
      child: MaterialApp(
        home: Scaffold(
          body: TodoListWidget(),
          floatingActionButton: Consumer(builder: (context, ref, child) {
            return FloatingActionButton(
              onPressed: () {
                ref
                    .read(todoListProvider)
                    .update((state) => [Todo('New Todo'), ...state.sublist(1)]);
              },
              child: Icon(Icons.add),
            );
          }),
        ),
      ),
    ),
  );
}
```

Which when run prints

```
flutter: Build List
flutter: Build Item 0
flutter: Build Item 1
flutter: Build Item 2
// After updating item 0 in the todoListProvider by pressing the FloatingActionButton
// you will then see:
flutter: Build Item 0
```

This approach comes with some nice organizational properties,
such as keeping your widget constructors clean from an ever growing list of parameters being passed down.

## Scoping Dependent Providers

In the previous example no other provider depended on the `todoItemIndexProvider`.

Let's change the example to use a dependent provider rather than a family.

This:

```dart
/// Provides a single todo, so you can watch them individually
///
/// This way you will only be notified if the particular todo you
/// were watching was updated
final todoProvider = Provider.family<Todo, int>(
    (ref, index) => ref.watch(todoListProvider).state[index]);
```

changes to:

```dart
/// Provides a single todo based on the todoItemIndexProvider
final todoProvider = Provider<Todo>(
    (ref) => ref.watch(todoListProvider).state[ref.watch(todoItemIndexProvider)]);
```

and this:

```dart
/// A widget to show a single todo
class TodoWidget extends ConsumerWidget {
  const TodoWidget();
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // Gets the index of this particular Todo
    final index = ref.watch(todoItemIndexProvider);
    print('Building Item $index');
    // Watches a single todo item
    final todoItem = ref.watch(todoProvider(index));
    // Display it!
    return Text(todoItem.todo);
  }
}
```

changes to:

```dart
/// A widget to show a single todo
class TodoWidget extends ConsumerWidget {
  const TodoWidget();
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // Watches a single todo item
    final todoItem = ref.watch(todoProvider);
    // Display it!
    return Text(todoItem.todo);
  }
}
```

Well if we try this with no other changes, we get an exception thrown!

```
An exception was thrown while building Provider<Todo>

Thrown exception:
An exception was thrown while building Provider<int>

Thrown exception:
UnimplementedError: Todo index not set
```

The problem is that riverpod does not know which scope to insert the
new `todoProvider` that you are trying to access in `TodoWidget`. By
default it places all providers in the root scope at the root of your
widget tree. This way you can access the same provider from all parts
of your app. But in that scope the `todoItemIndexProvider` provider is not overridden otherwise
you'd have the same todo index for the whole app.

The solution to this problem is to override the todoProvider for the subtree as well.

This:

```dart
itemBuilder: (context, index) {
        // Overrides the todoItemIndexProvider
        // for everything below this in the tree
        return ProviderScope(
          overrides: [
            todoItemIndexProvider.overrideWithValue(index),
          ],
          // Using this approach, TodoWidget can now be constant
          // since no index needs to be passed down
          child: const TodoWidget(),
        );
      },
```

changes to:

```dart
itemBuilder: (context, index) {
        // Overrides the todoItemIndexProvider
        // for everything below this in the tree
        return ProviderScope(
          overrides: [
            todoItemIndexProvider.overrideWithValue(index),
            todoProvider,
          ],
          // Using this approach, TodoWidget can now be constant
          // since no index needs to be passed down
          child: const TodoWidget(),
        );
      },
```

Hot restart your app, and everything should work! You've successfully used
scoped providers to get a unique instance of the todoProvider for each of
of the items in the `ListView`.

However, there is an even better way.
When declaring the `todoProvider` we can specify which providers it depends on
so that Riverpod can know at the time of overriding which dependent providers also
need overrides.

```dart
/// Provides a single todo based on the todoItemIndexProvider
final todoProvider = Provider<Todo>(
    (ref) => ref.watch(todoListProvider).state[ref.watch(todoItemIndexProvider)],
  dependencies: [todoItemIndexProvider]
);
```

Now the original code works, and `todoProvider` no longer needs to be manually overridden
if todoItemIndexProvider is overridden.
