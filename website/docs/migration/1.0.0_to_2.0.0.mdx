---
title: ^1.0.0 to ^2.0.0
---

import fromStateNotifier from "./from_state_notifier";
import fromStateNotifier2 from "./from_state_notifier_2";
import fromStateProvider from "./from_state_provider";
import oldLifecycles from "./old_lifecycles";
import {AutoSnippet} from "../../src/components/CodeSnippet";

Riverpod went `2.0`! To see the full list of changes, consult the [Changelog].

In this page, we will focus on:
- How to migrate from the deprecated `StateNotifier` to the new `Notifier` APIs
- How to handle the new `AsyncValue` behavior and its new properties
- How to migrate from `ProviderListener` to `ProviderObserver` for logging purposes


## Migrating from `StateNotifier`

Riverpod `2.0` introduced the new `Notifier` and `AsyncNotifier` classes.  
These two are meant to replace the legacy `StateNotifier` (and `ChangeNotifier`), with the following advantages:
- Conciseness and a better DX overall
- Codegen support
- One less [external dependency]
- Easier distinction between sync and async providers

Alas, these features introduce a few breaking changes. This page is meant to help you overcome these.

:::info
This migration guide can be used for migrating away from `ChangeNotifier` as well.
Its behavior is quite similar to its equivalent for immutable data, `StateNotifier`.
:::

### Initialization with `build`

When defining a `StateNotifierProvider` (or `ChangeNotifierProvider`), initialization is
typically placed inside the provider itself. Take the following example:

```dart
final randomProvider = Provider<int>((ref) {
  return Random().nextInt(6);
});

class DiceNotifier extends StateNotifier<int> {
  DiceNotifier(int random) : super(random + 1) {
    print('Post-initialization effects go here.');
    _startCamera();
  }

  void adjust(int offset) => state = state + offset;
}

final diceNotifierProvider = StateNotifierProvider<DiceNotifier, int>((ref) {
  final random = ref.watch(randomProvider);
  return DiceNotifier(random);
});
```

With the new `Notifier` class, the above example translates to:
<AutoSnippet language="dart" {...fromStateNotifier}></AutoSnippet>

You can notice the following differences:
- A more concise syntax, with no constructor logic
- There's a new `build` method instead, which specifies initialization logic and its reactive dependencies
- `NotifierProvider` has no `ref` in its build callback
- `Notifier` has its own `ref`, internally

### `Notifier` and `AsyncNotifier` have their own `ref` and family attributes

A common `pre-2.0` pattern was to pipe down a `Ref` parameter into your `StateNotifier` (or `ChangeNotifier`) classes.
This was useful for a plethora of reasons.  
Also, if such providers had family parameters, chances are that these parameters must have been piped down
to their `StateNotifier` (or `ChangeNotifier`), too.

`Notifier` (and `AsyncNotifier`), instead, have their own `Ref` getter, which is handy to perform
side effects, to invoke mutations and, as specified above, to write dependencies into its `build` method.

Also, `Notifier` (and `AsyncNotifier`) have their own `.family` counterpart, which has a more
transparent API; in a `Notifier` (or `AsyncNotifier`) parameters are explicitly stated and they are
injected in the `build` method, available to the initialization logic.

Take the above the example, with two slight variations.
- say a side-effect is required when invoking `adjust`;
- say that another *external* parameter is required when doing so.

We obtain:
```dart
class DiceNotifier extends StateNotifier<int> {
  DiceNotifier({
    required this.id,
    required int random,
    required this.ref,
  }) : super(random + 1);
  final String id;
  final Ref ref;

  void adjust(int offset) {
    ref.read(myRepositoryProvider).post(id: id, change: offset).ignore();
    state = state + offset;
  }
}

final diceNotifierProvider = StateNotifierProvider.family<DiceNotifier, int, String>((ref, id) {
  final random = ref.watch(randomProvider);
  return DiceNotifier(id: id, random: random, ref: ref);
});
```

As you can notice, `diceNotifierProvider` is now a `.family` provider. The whole thing works fine.

But with `Notifier` (and its `FamilyNotifier` variant), no pipe-down is ever needed.  
The `.family` modification, which is very important, is clearly stated in its own definition,
and it's used directly in its `build` method.  
The whole thing is more readable, more concise and less error-prone.
<AutoSnippet language="dart" {...fromStateNotifier2}></AutoSnippet>

Notice how the code-generated version is even more concise and less error-prone than ever.

:::info
`Notifier` and `AsyncNotifier` are intrinsically bound to the `.autoDispose` and `.family` features.
Enabling or disabling such features means it's needed to change the subclassed notifier type.

For example, to define an `AsyncNotifier` with `.autoDispose` and `.family` features altogether,
it is needed to extend `AutoDisposeFamilyAsyncNotifier`.
:::

### `Notifier` and `AsyncNotifier` have a different disposal behavior
Lifecycles  between `Notifier` (and `AsyncNotifier`) and `StateNotifier` (and `ChangeNotifier`)
differ substantially.

A `StateNotifier` (or a `ChangeNotifier`) instance is indeed bound to their outer
`StateNotifierProvider` (or `ChangeNotifierProvider`).  
When the latter rebuilds, their exposed value, aka its `StateNotifier` (or `ChangeNotifier`)
is `disposed`, and then re-created (i.e. its constructor gets invoked again).

Take this example:
```dart
class MyNotifier extends StateNotifier<int> {
  MyNotifier(this.period) : super(0) {
    _timer = Timer.periodic(period, (t) => update());
  }
  final Duration period;
  late final Timer _timer;

  void update() => state++;

  @override
  void dispose() {
    _timer.cancel();
    super.dispose();
  }
}

final myNotifierProvider = StateNotifierProvider<MyNotifier, int>((ref) {
  final Duration period = ref.watch(durationProvider);
  return MyNotifier(period);
});
```

A first takeaway from this example is the following: *if `durationProvider` updates,
`MyNotifier` disposes*.  
As stated above, its instance is then re-created and its internal state re-initialized as usual.

The second takeaway is that, unlike every other provider, the `dispose` callback is to be defined
in the class, separately.  
It is still possible to write `ref.onDispose` in its *provider*,
but two different dispose callbacks are to be maintained.

This API ambiguity is solved with `Riverpod 2.0`.  
Check the above example, migrated to its `Notifier` equivalent.
<AutoSnippet language="dart" {...oldLifecycles}></AutoSnippet>

Here, instead, `MyNotifier`, will *not* dispose when `durationProvider` updates:
only its *internal state* will.  
This breaking change simplifies the API and, hopefully, your DX, for two reasons:
1. there is only one lifecycle to take care of, the one we really care about: `Notifier`'s inner state;
2. there is only one API to register a `dispose` action: `ref.onDispose`.

### Final remarks
When transitioning to `Notifier` (or `AsyncNotifier`), it is good to keep in mind some more differences.

#### Migrating from `.addListener` and `.stream`
`StateNotifier`'s `.addListener` and `.stream` can be used to listen for state changes.
These two APIs aren't a thing within `Notifier` or `AsyncNotifier`.

This is intentional due to the API uniformity `Notifier` and `AsyncNotifier` offer.
Indeed, using a `Notifier` or an `AsyncNotifier` shouldn't be any different from any other provider.

So, if you want to listen to a `Notifier`, just use `ref.listen`, [as explained here].

#### Moving from `StateNotifier.debugState`
WIP

#### Moving from `StateNotifier.mounted`
WIP

## Migrating from `StateProvider`

`StateProvider` was exposed by Riverpod's libraries to save a few LoC when in need of a `StateNotifierProvider`.  
Since `StateNotifierProvider` is deprecated, `StateProvider` is to be avoided, too.

To migrate away from `StateProvider` and towards `Notifier` is simple.  
Take this example:

```dart
final counterProvider = StateProvider<int>((ref) {
  return 0;
});
```

When migrating to `Notifier`, this becomes:
<AutoSnippet language="dart" {...oldLifecycles}></AutoSnippet>

Even though it costs us a few more LoC, migrating away from `StateProvider` brings way more advantages, as shown above.

## An improved `AsyncValue`
WIP

### `AsyncValue` can expose two or more values at the same time
e.g. "hasValue=true", "hasError=true" and "isLoading=true"
WIP

### How to work around the new APIs
valueOrNull, hasError, hasData, asError, isLoading, etc.
WIP

## `ProviderListener` is not a thing anymore
use ProviderObserver instead 
WIP

[Changelog]: https://pub.dev/packages/flutter_riverpod/changelog#200
[external dependency]: https://github.com/rrousselGit/state_notifier
[as explained here]: /docs/concepts/reading#using-reflisten-to-react-to-a-provider-change
