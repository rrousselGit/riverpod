---
title: ^1.0.0 to ^2.0.0
---

import fromStateNotifier from "./from_state_notifier";
import fromStateNotifier2 from "./from_state_notifier_2";
import fromStateProvider from "./from_state_provider";
import oldLifecycles from "./old_lifecycles";
import {AutoSnippet} from "../../src/components/CodeSnippet";

Riverpod went `2.0`! To see the full list of changes, consult the [Changelog].

In this page, we will focus on:
- How to migrate from the deprecated `StateNotifier` to the new `Notifier`
- How to handle the new `AsyncValue` behavior and its new properties
- How to migrate from `ProviderListener` to `ProviderObserver` for logging purposes


## Migrating from `StateNotifier`

Riverpod `2.0` introduced the new `Notifier` and `AsyncNotifier` classes.  
These two are meant to replace the - now - legacy `StateNotifier`, with the following advantages:
- Codegen support
- One less [external dependency]
- Easier distinction between sync and async providers
- Easier provider initialization

Alas, these features introduce a few breaking changes. This page is meant to help you overcome these.

:::info
This migration guide is useful for migrating away from `ChangeNotifier` as well.
:::

### Initialization with `build`

When defining a `StateNotifierProvider` (or `ChangeNotifierProvider`), initialization was
typically placed inside the provider itself. Take the following example:

```dart
final randomProvider = Provider<int>((ref) {
  return Random().nextInt(6);
});

class DiceNotifier extends StateNotifier<int> {
  DiceNotifier(this.random) : super(random + 1);
  final int random;

  void adjust(int offset) => state = state + offset;
}

final diceNotifierProvider = StateNotifierProvider<DiceNotifier, int>((ref) {
  final random = ref.watch(randomProvider);
  return DiceNotifier(random);
});
```

With the new `Notifier` class, the above example translates to:
<AutoSnippet language="dart" {...fromStateNotifier}></AutoSnippet>

You can notice the following differences:
- More concise syntax
- No constructor specification needed
- Initialization is done in the new `build` method
- Dependencies are specified directly in the new `build` method
- `NotifierProvider` has no `ref` in its build callback

### `Notifier` and `AsyncNotifier` have their own `ref`

A common `pre-2.0` pattern was to pipe down a `Ref` parameter into your `StateNotifier` (or `ChangeNotifier`) classes.
This was useful for a plethora of reasons.

`Notifier` (and `AsyncNotifier`) have their own `Ref` getter, which is handy
to perform side effects, mutations and, as specified above, to write dependencies into its `build` method.

Taking the above example, say a side-effect is required when invoking `adjust`:

```dart
class DiceNotifier extends StateNotifier<int> {
  DiceNotifier(this.dice, this.ref) : super(dice + 1);
  final int dice;
  final Ref ref;

  void adjust(int offset) {
    ref.read(myRepositoryProvider).post(change: offset).ignore();
    state = state + offset;
  }
}
```

With `Notifier`, no pipe-down is ever needed.
<AutoSnippet language="dart" {...fromStateNotifier2}></AutoSnippet>

### `Notifier` and `AsyncNotifier` have a different disposal behavior
One main difference  between `Notifier` (and `AsyncNotifier`) and `StateNotifier` (and `ChangeNotifier`)
is their lifecycle.  
Indeed, while their internal state's lifecycle is identical to any other provider,
their surrounding class behaves differently.

A `StateNotifier` (or a `ChangeNotifier`) instance is indeed bound to their outer
`StateNotifierProvider` (or `ChangeNotifierProvider`). When the latter rebuilds, their exposed value,
aka its `StateNotifier` (or `ChangeNotifier`) is `disposed`, and then re-created (through its constructor).

Take this example:
```dart
class MyNotifier extends StateNotifier<int> {
  MyNotifier(this.period) : super(0) {
    _timer = Timer.periodic(period, (t) => update());
  }
  final Duration period;
  late final Timer _timer;

  void update() => state++;

  @override
  void dispose() {
    _timer.cancel();
    super.dispose();
  }
}

final myNotifierProvider = StateNotifierProvider<MyNotifier, int>((ref) {
  final Duration period = ref.watch(durationProvider);
  return MyNotifier(period);
});
```

A first takeaway from this example is the following: *if `durationProvider` updates,
`MyNotifier` disposes*. Its instance is then re-created and its internal state re-initialized as usual.

The second takeaway from the above example is that, unlike every other provider,
the `dispose` callback is to be defined in the class. It is still possible to write `ref.onDispose`,
but two different dispose cycles are to be maintained.

Then, check the same example, migrated to its `Notifier` equivalent.
<AutoSnippet language="dart" {...oldLifecycles}></AutoSnippet>

Here, instead, `MyNotifier`, *will not dispose* when `durationProvider` updates:
**only its internal state will**.

This incredibly simplifies the API for you, the developer. There is only one lifecycle to take care of:
the one we really care about, `Notifier`'s inner state.

Finally, notice how to register a `dispose` action we use `ref.onDispose`, just like we would with any
other provider.

## Migrating from `StateProvider`

`StateProvider` was exposed by Riverpod's libraries to save a few LoC when in need of a `StateNotifierProvider`.  
Since `StateNotifierProvider` is deprecated, `StateProvider` is to be avoided, too.

To migrate away from `StateProvider` and towards `Notifier` is simple.  
Take this example:

```dart
final counterProvider = StateProvider<int>((ref) {
  return 0;
});
```

When migrating to `Notifier`, this becomes:
<AutoSnippet language="dart" {...oldLifecycles}></AutoSnippet>

Even though it costs us a few more LoC, migrating away from `StateProvider` brings way more advantages, as shown above.


[Changelog]: https://pub.dev/packages/flutter_riverpod/changelog#200
[external dependency]: https://github.com/rrousselGit/state_notifier