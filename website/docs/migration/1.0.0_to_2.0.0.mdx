---
title: ^1.0.0 to ^2.0.0
---

import fromStateNotifier from "./from_state_notifier";
import fromStateNotifier2 from "./from_state_notifier_2";
import fromStateProvider from "./from_state_provider";
import {AutoSnippet} from "../../src/components/CodeSnippet";

Riverpod went `2.0`! To see the full list of changes, consult the [Changelog].

In this page, we will focus on:
- How to migrate from the deprecated `StateNotifier` to the new `Notifier`
- How to handle the new `AsyncValue` behavior and its new properties
- How to migrate from `ProviderListener` to `ProviderObserver` for logging purposes


## Migrating from `StateNotifier`

Riverpod `2.0` introduced the new `Notifier` and `AsyncNotifier` classes.  
These two are meant to replace the - now - legacy `StateNotifier`, with the following advantages:
- Codegen support
- One less [external dependency]
- Easier distinction between sync and async providers
- Easier provider initialization

Alas, these features introduce a few breaking changes. This page is meant to help you overcome these.

:::info
This migration guide is useful for migrating away from `ChangeNotifier` as well.
:::

### Initialization with `build`

When defining a `StateNotifierProvider` (or `ChangeNotifierProvider`), initialization was
typically placed inside the provider itself. Take the following example:

```dart
final randomProvider = Provider<int>((ref) {
  return Random().nextInt(6);
});

class DiceNotifier extends StateNotifier<int> {
  DiceNotifier(this.random) : super(random + 1);
  final int random;

  void adjust(int offset) => state = state + offset;
}

final diceNotifierProvider = StateNotifierProvider<DiceNotifier, int>((ref) {
  final random = ref.watch(randomProvider);
  return DiceNotifier(random);
});
```

With the new `Notifier` class, the above example translates to:
<AutoSnippet language="dart" {...fromStateNotifier}></AutoSnippet>

You can notice the following differences:
- More concise syntax
- No constructor specification needed
- Initialization is done in the new `build` method
- Dependencies are specified directly in the new `build` method
- `NotifierProvider` has no `ref` in its build callback

### `Notifier` and `AsyncNotifier` have their own `ref`

A common `pre-2.0` pattern was to pipe down a `Ref` parameter into your `StateNotifier` (or `ChangeNotifier`) classes.
This was useful for a plethora of reasons.

`Notifier` (and `AsyncNotifier`) have their own `Ref` getter, which is handy
to perform side effects, mutations and, as specified above, to write dependencies into its `build` method.

Taking the above example, say a side-effect is required when invoking `adjust`:

```dart
class DiceNotifier extends StateNotifier<int> {
  DiceNotifier(this.dice, this.ref) : super(dice + 1);
  final int dice;
  final Ref ref;

  void adjust(int offset) {
    ref.read(myRepositoryProvider).post(change: offset).ignore();
    state = state + offset;
  }
}
```

With `Notifier`, no pipe-down is ever needed.
<AutoSnippet language="dart" {...fromStateNotifier2}></AutoSnippet>

## Migrating from `StateProvider`

`StateProvider` was exposed by Riverpod's libraries to save a few LoC when in need of a `StateNotifierProvider`.  
Since `StateNotifierProvider` is deprecated, `StateProvider` is to be avoided, too.

To migrate away from `StateProvider` and towards `Notifier` is simple.  
Take this example:

```dart
final counterProvider = StateProvider<int>((ref) {
  return 0;
});
```

With a simple migration, this becomes:
<AutoSnippet language="dart" {...fromStateProvider}></AutoSnippet>

Even though it costs us a few more LoC, migrating away from `StateProvider` brings way more advantages, as shown above.


[Changelog]: https://pub.dev/packages/flutter_riverpod/changelog#200
[external dependency]: https://github.com/rrousselGit/state_notifier