---
title: From `ChangeNotifier`
---

import old from "./from_change_notifier/old";
import declaration from "./from_change_notifier/declaration";
import initialization from "./from_change_notifier/initialization";
import migrated from "./from_change_notifier/migrated";

import { AutoSnippet } from "../../src/components/CodeSnippet";


Within Riverpod, `ChangeNotifierProvider` is meant to be used to offer a smooth transition from
pkg:provider.

If you've just started a migration to pkg:riverpod, make sure you read the dedicated
[quickstart guide](/docs/from_provider/quickstart).  
This article is meant for folks that already transitioned to riverpod, but want to move away from
`ChangeNotifier` definetively.

All in all, migrating from `ChangeNotifier` to `AsyncNotifer` requires a
[paradigm shift](why-immutability), but it brings great simplification with the resulting migrated
code.

Take this example:
<AutoSnippet language="dart" {...old}></AutoSnippet>

This implementation shows several faulty design choices such as:
- The usage of `isLoading` and `hasError` to handle different asynchronous cases
- The need to carefully handle requests with tedious `try`/`catch`/`finally` expressions
- The need to inkove `notifyListeners` at the right times to make this implementation work
- The presence of inconsistent or possibly undesirable states, e.g. initialization with an empty list

Note how this example has been crafted to show how `ChangeNotifier` can lead to faulty design choices
for newbie developers; also, another takeaway is that mutable state might be way harder than it
initially promises.

`Notifier`/`AsyncNotifer`, in combination with immutable state, can lead to better design choices
and less errors.

Let's see how to migrate the above snippet, one step at a time, towards the newest APIs.


## Declare your `AsyncNotifier`
First, we should declare the new provider / notifier.  
This requires some thought process which depends on your unique business logic.

The best fit here is to use an `AutoDisposeAsyncNotifier<List<Todo>>`, which meets all the
requirements:
- Initialization is asynchronous
- There's the need to notify about asynchronous states (loading, error, etc.)
- State can be mutated via exposed methods

If you're using code generation, there's no need to think about the right class name
at all: you just write its return type and you're good to go.

<AutoSnippet language="dart" {...declaration}></AutoSnippet>

Another difference is that we don't need to declare `todos` anymore; such variable is implicitly
loaded with the logic inside `build`, and it's called `state`. Indeed, notifiers can expose one
state variable at a time.

Remember: you can use [snippets in your IDE](/docs/introduction/getting_started#going-further-installing-code-snippets)
to speed up declarations.

:::info
Riverpod exposes a plethora of provider and notifiers which can be confusing at first, but they
make more sense the more you use them. 
If you need help finding the right provider, read [this guide](TODO) about provider types.
:::


## Initialization
Initalizing a notifier is easy: just write initialization logic inside `build`;
there's no need to define a separate `_init` function.

<AutoSnippet language="dart" {...initialization}></AutoSnippet>

The new `build` method is more concise than the old `_init`: there is no need to initialize
variables such as `isLoading` or `hasError` anymore.

Our `AsyncNotifier` is now exposing an `AsyncValue<List<Todo>>`, which handles the intricacies of
asynchronous state better than what two boolean flags can do.

Indeed, `MyNotifier` initializes with `AsyncLoading`, as it's waiting for the network request to
complete.
When the asynchronous operation completes, the notifier will automatically transform errors to
`AsyncError`, and valid data to `AsyncData`: any `try/catch/finally` constructs are useless now.


## Mutations and Side Effects
Just like initialization, mutating state / performing side effects is more concise in a notifier.
Again, there's no need to manipulate boolean flags such as `hasError`, or to write
`try/catch/finally` blocks.

Syntax and design choices may vary, but in the end we just need to write our request and update
state afterwards. Please read more about performing side effects in its
[dedicated page](/docs/essentials/side_effects).

With this final step, we've successfully fully migrated this example with `AsyncNotifier`:

<AutoSnippet language="dart" {...migrated}></AutoSnippet>

## Migration Process Summary

Let's analyze the whole migration process applied here:
1. We've moved the initialization, away from a custom method invoked in a constructor, to `build`
2. We've removed `todos`, `isLoading` and `hasError` properties: internal `state` will suffice
3. Indeed, since `build` returns a `Future<List<Todo>>`, state is implicitly initialized with `AsyncLoading`
4. We've returned the result of the asynchronous request, with no try-catch-finally blocks
5. Indeed, when `build` completes, `state` will either be `AsyncData` or `AsyncError`
6. We've then simplified `addTodo`, performing this side effect without any boilerplate
7. Indeed, to apply mutations, we simply reassign `state`: listeners will be automatically notified about it

