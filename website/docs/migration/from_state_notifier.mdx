---
title: From `StateNotifier` (and `ChangeNotifier`)
---

import buildIinit from "./build_init";
import familyAndDispose from "./family_and_dispose";
import fromStateProvider from "./from_state_provider";
import oldLifecycles from "./old_lifecycles";
import {AutoSnippet} from "../../src/components/CodeSnippet";

Riverpod went `2.0`! To see the full list of changes, consult the
[Changelog](https://pub.dev/packages/flutter_riverpod/changelog#200).

Riverpod `2.0` introduced the new `Notifier` and `AsyncNotifier` classes.  
This page shows how to migrate from the deprecated `StateNotifier` (and from the legacy `ChangeNotifier`)
to the new APIs.

The main benefit introduced by `AsyncNotifier` is better `async` support; indeed,
`AsyncNotifier` can be thought as a `FutureProvider` with methods.

Furthermore, the new Notifiers:
- Expose a `Ref` object inside its class
- Offer similar syntax between codegen and non-codegen approaches
- Offer similar syntax between their sync and async versions
- Move away logic from Providers and centralize it into the Notifiers themselves


Alas, these features introduce a few breaking changes. This page is meant to help you overcome these.

:::info
This migration guide can be used for migrating away from `ChangeNotifier` as well.
Its behavior is quite similar to its equivalent for immutable data, `StateNotifier`.
:::

### Initialization comes with a `build` method

When defining a `StateNotifierProvider` (or `ChangeNotifierProvider`), initialization is
typically placed inside the provider itself. Take the following example:

```dart
final randomProvider = Provider<int>((ref) {
  return Random().nextInt(6);
});

class DiceNotifier extends StateNotifier<int> {
  DiceNotifier(int random) : super(random + 1) {
    print('Post-initialization effects go here.');
    _startCamera();
  }

  void adjust(int offset) => state = state + offset;
}

final diceNotifierProvider = StateNotifierProvider<DiceNotifier, int>((ref) {
  final random = ref.watch(randomProvider);
  return DiceNotifier(random);
});
```

With the new `Notifier` class, the above example translates to:
<AutoSnippet language="dart" {...buildIinit}></AutoSnippet>

You can notice the following differences:
- A more concise syntax, with no constructor logic
- There's a new `build` method instead, which specifies initialization logic and its reactive dependencies
- `NotifierProvider` has no `ref` in its build callback
- `Notifier` has its own `ref`, internally

### `ref` and family attributes are exposed by their classes directly

A common `pre-2.0` pattern was to pipe down a `Ref` parameter into your `StateNotifier` (or `ChangeNotifier`) classes.
This was useful for a plethora of reasons.  
Also, if such providers had family parameters, chances are that these parameters must have been piped down
to their `StateNotifier` (or `ChangeNotifier`), too.

`Notifier` (and `AsyncNotifier`), instead, have their own `Ref` getter, which is handy to perform
side effects, to invoke mutations and, as specified above, to write dependencies into its `build` method.

Also, `Notifier` (and `AsyncNotifier`) have their own `.family` counterpart, which has a more
transparent API; in a `Notifier` (or `AsyncNotifier`) parameters are explicitly stated and they are
injected in the `build` method, available to the initialization logic.

Take the above the example, with two slight variations.
- say a side-effect is required when invoking `adjust`;
- say that another *external* parameter is required when doing so.

We obtain:
```dart
class DiceNotifier extends StateNotifier<int> {
  DiceNotifier({
    required this.id,
    required int random,
    required this.ref,
  }) : super(random + 1);
  final String id;
  final Ref ref;

  void adjust(int offset) {
    ref.read(myRepositoryProvider).post(id: id, change: offset).ignore();
    state = state + offset;
  }
}

final diceNotifierProvider = StateNotifierProvider.family<DiceNotifier, int, String>((ref, id) {
  final random = ref.watch(randomProvider);
  return DiceNotifier(id: id, random: random, ref: ref);
});
```

As you can notice, `diceNotifierProvider` is now a `.family` provider. The whole thing works fine.

But with `Notifier` (and its `FamilyNotifier` variant), no pipe-down is ever needed.  
The `.family` modification, which is very important, is clearly stated in its own definition,
and it's used directly in its `build` method.  
The whole thing is more readable, more concise and less error-prone.
<AutoSnippet language="dart" {...familyAndDispose}></AutoSnippet>

Notice how the code-generated version is even more concise and less error-prone than ever.

:::info
`Notifier` and `AsyncNotifier` are intrinsically bound to the `.autoDispose` and `.family` features.
Enabling or disabling such features means it's needed to change the subclassed notifier type.

For example, to define an `AsyncNotifier` with `.autoDispose` and `.family` features altogether,
it is needed to extend `AutoDisposeFamilyAsyncNotifier`.
:::

### Lifecycles (and `dispose`) have a different behavior
Lifecycles  between `Notifier` (and `AsyncNotifier`) and `StateNotifier` (and `ChangeNotifier`)
differ substantially.

A `StateNotifier` (or a `ChangeNotifier`) instance is indeed bound to their outer
`StateNotifierProvider` (or `ChangeNotifierProvider`).  
When the latter rebuilds, their exposed value, aka its `StateNotifier` (or `ChangeNotifier`)
is `disposed`, and then re-created (i.e. its constructor gets invoked again).

Take this example:
```dart
class MyNotifier extends StateNotifier<int> {
  MyNotifier(this.period) : super(0) {
    _timer = Timer.periodic(period, (t) => update());
  }
  final Duration period;
  late final Timer _timer;

  void update() => state++;

  @override
  void dispose() {
    _timer.cancel();
    super.dispose();
  }
}

final myNotifierProvider = StateNotifierProvider<MyNotifier, int>((ref) {
  final Duration period = ref.watch(durationProvider);
  return MyNotifier(period);
});
```

A first takeaway from this example is the following: *if `durationProvider` updates,
`MyNotifier` disposes*.  
As stated above, its instance is then re-created and its internal state re-initialized as usual.

The second takeaway is that, unlike every other provider, the `dispose` callback is to be defined
in the class, separately.  
It is still possible to write `ref.onDispose` in its *provider*,
but two different dispose callbacks are to be maintained.

This API ambiguity is solved with `Riverpod 2.0`.  
Check the above example, migrated to its `Notifier` equivalent.
<AutoSnippet language="dart" {...oldLifecycles}></AutoSnippet>

Here, instead, `MyNotifier`, will *not* dispose when `durationProvider` updates:
only its *internal state* will.  
This breaking change simplifies the API and, hopefully, your DX, for two reasons:
1. there is only one lifecycle to take care of, the one we really care about: `Notifier`'s inner state;
2. there is only one API to register a `dispose` action: `ref.onDispose`.

### There is no `.mounted` property
WIP

### Final remarks
When transitioning to `Notifier` (or `AsyncNotifier`), it is good to keep in mind some more differences.

#### Migrating from `.addListener` and `.stream`
`StateNotifier`'s `.addListener` and `.stream` can be used to listen for state changes.
These two APIs aren't a thing within `Notifier` or `AsyncNotifier`.

This is intentional due to the API uniformity `Notifier` and `AsyncNotifier` offer.
Indeed, using a `Notifier` or an `AsyncNotifier` shouldn't be any different from any other provider.

So, if you want to listen to a `Notifier`, just use `ref.listen`,
[as explained here](/docs/concepts/reading#using-reflisten-to-react-to-a-provider-change).

#### Migrating from `.debugState`
`StateNotifier` exposed a `.debugState` getter that isn't a thing on `Notifier`.  
This property had some use within `state_notifier`, as it enabled accessing state
from outside the class when in development mode, aka for testing purposes.

Again, for uniformity reasons, it doesn't make sense to expose such property on a `Notifier`
(or on an `AsyncNotifier`).  
If you want to interact with `Notifier` or `AsyncNotifier` in a testing environment, you should do
it just like with any other provider: by reading them directly (as opposed of directly instantiating
a `Notifier` by hand).

This [testing guide](/docs/cookbooks/testing) fully explains how to use `ProviderContainer.read` to do so.


## Migrating from `StateProvider`

`StateProvider` was exposed by Riverpod's libraries to save a few LoC when in need of a
simplified version of `StateNotifierProvider`.  
Since `StateNotifierProvider` is deprecated, `StateProvider` is to be avoided, too.

To migrate from `StateProvider` and towards `Notifier` is simple. Take this example:

```dart
final counterProvider = StateProvider<int>((ref) {
  return 0;
});
```

When migrating to `Notifier`, this becomes:
<AutoSnippet language="dart" {...fromStateProvider}></AutoSnippet>

Even though it costs us a few more LoC, migrating away from `StateProvider` brings way more advantages, as shown above.
