---
title: From `StateNotifier` and `ChangeNotifier`
---

import buildIinit from "./build_init";
import familyAndDispose from "./family_and_dispose";
import asyncNotifier from "./async_notifier";
import fromStateProvider from "./from_state_provider";
import oldLifecycles from "./old_lifecycles";
import {AutoSnippet} from "../../src/components/CodeSnippet";

Riverpod went `2.0`! To see the full list of changes, consult the
[Changelog](https://pub.dev/packages/flutter_riverpod/changelog#200).

Riverpod `2.0` introduced the new `Notifier` and `AsyncNotifier` classes.  
This page shows how to migrate from the deprecated `StateNotifier` (and from the legacy `ChangeNotifier`)
to the new APIs.

The main benefit introduced by `AsyncNotifier` is a better `async` support; indeed,
`AsyncNotifier` can be thought as a `FutureProvider` with methods.

Furthermore, the new `Notifier`s:
- Expose a `Ref` object inside its class
- Offer similar syntax between codegen and non-codegen approaches
- Offer similar syntax between their sync and async versions
- Move away logic from Providers and centralize it into the Notifiers themselves

Let's see how to define a `Notifier`, how it compares with `StateNotifier` and explore
the new `AsyncNotifier` for asynchronous state classes.

## The new syntax
Let's write some simple logic with a synchronous `Notifier`:
<AutoSnippet language="dart" {...buildIinit}></AutoSnippet>

Notice the following design choices:
- Notifiers are initialized in their `build` method, along with their reactive dependencies
- Notifiers expose `ref` into their class, whereas their Provider don't 

### Comparison with `StateNotifier`

Let's compare the new APIs with the old ones; here, we implement the above example with `StateNotifier`:

```dart
class WellNotifier extends StateNotifier<int> {
  WellNotifier(int availableToDrink) : super(availableToDrink);

  void drink(int liters) => state = min(state - liters, 0);
}

final wellNotifierProvider = StateNotifierProvider<WellNotifier, int>((ref) {
  final availableToDrink = ref.watch(availableWater);
  return WellNotifier(availableToDrink);
});
```

Let's recap the main differences:
- `StateNotifier`'s reactive dependencies are declared in its provider, whereas `Notifier`
centralizes this logic in its `build` method
- Indeed, `StateNotifier`'s whole initialization process is split between its provider and its constructor,
whereas `Notifier` reserves a single place to place such logic
- Notice how, as opposed to `StateNotifier`, no logic is ever written into a `Notifier`'s constructor

Similar conclusions can be made with `AsyncNotifer`, `Notifier`'s asynchronous equivalent.  
Let's check it out.

## Better async support with `AsyncNotifier`
The main appeal of the new API syntax is an improved DX on asynchronous states.  
Previously, with `StateNotifier`, we would handle that like so:
```dart
class AsyncTodosNotifier extends StateNotifier<AsyncValue<List<Todo>>> {
  AsyncTodosNotifier() : super(const AsyncLoading()) {
    _postInit();
  }

  Future<void> _postInit() async {
    state = await AsyncValue.guard(
      // mock of a network request
      () => Future.delayed(const Duration(seconds: 1), () => []),
    );
  }

  // ...
}
```
This heavy syntax suffers from the same defects showed above.  
`AsyncNotifer`, just like `Notifier`, brings a simple and uniform API. Here, it's easy to see
`AsyncNotifer` as a `FutureProvider` with methods.

Here's the above example, rewritten with the new `AsyncNotifier` APIs:
<AutoSnippet language="dart" {...asyncNotifier}></AutoSnippet>

Therefore, migrating from `StateNotifier<AsyncValue<T>>` to a `AsyncNotifer<T>` should be very straightforward:
- Place the initialization logic directly into `build`: there's no need to define a `_postInit` method anymore
- There's no need to explicitly initialize `state` with `AsyncLoading`: as long as `build` returns a `Future`,
this will be handled by `AsyncNotifer`, directly
- You can evaluate an initialization synchronously, if ever needed: just avoid returning a `Future` in your `build` method,
i.e. let `build` be synchronous (this is the equivalent of initializing `StateNotifier` with an `AsyncData`)

Finally, `AsyncNotifer` comes with a set of utilities and getters that `StateNotifier` doesn't have, such as e.g.
[`future`](https://pub.dev/documentation/riverpod/latest/riverpod/AutoDisposeAsyncNotifier/future.html)
and [`update`](https://pub.dev/documentation/riverpod/latest/riverpod/AutoDisposeAsyncNotifier/update.html). 
This enables us to write much simpler logic when handling asynchronous mutations.

## Differences with `.family` and their attributes

When a `StateNotifier` had family parameters, these were defined in its provider, and chances are
that these parameters must have been piped down its class, too.

`Notifier` and `AsyncNotifier`, instead, have their own `.family` counterpart: `FamilyNotifier`
and `FamilyAsyncNotifier`.  
A main difference is that parameters are explicitly stated and they are directly injected in their
`build` method, so that they're available to the initialization logic.    
This should bring better readability, more conciseness and less mistakes.

Take the following example, in which a `StateNotifierProvider.family` is being defined.
```dart
class BugsEncounteredNotifier extends StateNotifier<AsyncValue<int>> {
  BugsEncounteredNotifier({
    required this.ref,
    required this.featureId,
  }) : super(const AsyncData(99));
  final String featureId;
  final Ref ref;

  Future<void> fix(int amount) async {
    state = await AsyncValue.guard(() async {
      final old = state.requireValue;
      final result = await ref.read(taskTrackerProvider).fix(id: featureId, fixed: amount);
      return max(old - result, 0);
    });
  }
}

final bugsEncounteredNotifierProvider =
    StateNotifierProvider.family<BugsEncounteredNotifier, int, String>((ref, id) {
  return BugsEncounteredNotifier(ref: ref, featureId: id);
});
```

Now, let's take a look at the new and improved `AsyncNotifier`:

<AutoSnippet language="dart" {...familyAndDispose}></AutoSnippet>

The exact same example should feel way lighter, and should have better readability than before.

:::info
`Notifier` and `AsyncNotifier` are intrinsically bound to the `.autoDispose` as well.
Enabling or disabling such features means it's needed to change the subclassed notifier type.  
For example, to define an `AsyncNotifier` with `.autoDispose` and `.family` features altogether,
it is needed to extend `AutoDisposeFamilyAsyncNotifier`.
:::

## Other differences
Let's explore the less-impactful differences between `StateNotifier` and `Notifier` (or `AsyncNotifier`)

### Lifecycles have a different behavior
Lifecycles  between `Notifier` (and `AsyncNotifier`) and `StateNotifier` (and `ChangeNotifier`)
differ substantially.

A `StateNotifier` (or a `ChangeNotifier`) instance is indeed bound to their outer
`StateNotifierProvider` (or `ChangeNotifierProvider`).  
When the latter rebuilds, their exposed value, aka its `StateNotifier` (or `ChangeNotifier`)
is `disposed`, and then re-created (i.e. its constructor gets invoked again).

Take this example:
```dart
class MyNotifier extends StateNotifier<int> {
  MyNotifier(this.period) : super(0) {
    _timer = Timer.periodic(period, (t) => update());
  }
  final Duration period;
  late final Timer _timer;

  void update() => state++;

  @override
  void dispose() {
    _timer.cancel();
    super.dispose();
  }
}

final myNotifierProvider = StateNotifierProvider<MyNotifier, int>((ref) {
  final Duration period = ref.watch(durationProvider);
  return MyNotifier(period);
});
```

A first takeaway from this example is the following: *if `durationProvider` updates,
`MyNotifier` disposes*.  
As stated above, its instance is then re-created and its internal state re-initialized as usual.

The second takeaway is that, unlike every other provider, the `dispose` callback is to be defined
in the class, separately.  
It is still possible to write `ref.onDispose` in its *provider*,
but two different dispose callbacks are to be maintained.

This API ambiguity is solved with `Riverpod 2.0`.  
Check the above example, migrated to its `Notifier` equivalent.
<AutoSnippet language="dart" {...oldLifecycles}></AutoSnippet>

Here, instead, `MyNotifier`, will *not* dispose when `durationProvider` updates:
only its *internal state* will.  
This breaking change simplifies the API and, hopefully, your DX, for two reasons:
1. there is only one lifecycle to take care of, the one we really care about: `Notifier`'s inner state;
2. there is only one API to register a `dispose` action: `ref.onDispose`.

### There is no `.mounted` property
WIP

### Final remarks
When transitioning to `Notifier` (or `AsyncNotifier`), it is good to keep in mind some more differences.

#### Migrating from `.addListener` and `.stream`
`StateNotifier`'s `.addListener` and `.stream` can be used to listen for state changes.
These two APIs aren't a thing within `Notifier` or `AsyncNotifier`.

This is intentional due to the API uniformity `Notifier` and `AsyncNotifier` offer.
Indeed, using a `Notifier` or an `AsyncNotifier` shouldn't be any different from any other provider.

So, if you want to listen to a `Notifier`, just use `ref.listen`,
[as explained here](/docs/concepts/reading#using-reflisten-to-react-to-a-provider-change).

#### Migrating from `.debugState`
`StateNotifier` exposed a `.debugState` getter that isn't a thing on `Notifier`.  
This property had some use within `state_notifier`, as it enabled accessing state
from outside the class when in development mode, aka for testing purposes.

Again, for uniformity reasons, it doesn't make sense to expose such property on a `Notifier`
(or on an `AsyncNotifier`).  
If you want to interact with `Notifier` or `AsyncNotifier` in a testing environment, you should do
it just like with any other provider: by reading them directly (as opposed of directly instantiating
a `Notifier` by hand).

This [testing guide](/docs/cookbooks/testing) fully explains how to use `ProviderContainer.read` to do so.


## Migrating from `StateProvider`

`StateProvider` was exposed by Riverpod's libraries to save a few LoC when in need of a
simplified version of `StateNotifierProvider`.  
Since `StateNotifierProvider` is deprecated, `StateProvider` is to be avoided, too.

To migrate from `StateProvider` and towards `Notifier` is simple. Take this example:

```dart
final counterProvider = StateProvider<int>((ref) {
  return 0;
});
```

When migrating to `Notifier`, this becomes:
<AutoSnippet language="dart" {...fromStateProvider}></AutoSnippet>

Even though it costs us a few more LoC, migrating away from `StateProvider` brings way more advantages, as shown above.
