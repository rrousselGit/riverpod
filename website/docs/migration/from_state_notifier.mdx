---
title: From `StateNotifier` and `ChangeNotifier`
---

import buildIinit from "./build_init";
import familyAndDispose from "./family_and_dispose";
import asyncNotifier from "./async_notifier";
import addListener from "./add_listener";
import fromChangeNotifier from "./from_change_notifier";
import fromStateProvider from "./from_state_provider";
import oldLifecycles from "./old_lifecycles";
import { AutoSnippet } from "../../src/components/CodeSnippet";

Along with [Riverpod 2.0](https://pub.dev/packages/flutter_riverpod/changelog#200), new classes
were introduced: `Notifier` / `AsyncNotifer`.  
The good old `StateNotifier` / `ChangeNotifier` classes are now discouraged in favor of those new APIs.

This page shows how to migrate from the deprecated `StateNotifier` (and from the legacy `ChangeNotifier`)
to the new APIs.

The main benefit introduced by `AsyncNotifier` is a better `async` support; indeed,
`AsyncNotifier` can be thought as a `FutureProvider` which can expose ways to be modified from the UI..

Furthermore, the new `(Async)Notifier`s:

- Expose a `Ref` object inside its class
- Offer similar syntax between codegen and non-codegen approaches
- Offer similar syntax between their sync and async versions
- Move away logic from Providers and centralize it into the Notifiers themselves

Let's see how to define a `Notifier`, how it compares with `StateNotifier` and explore
the new `AsyncNotifier` for asynchronous state classes.

## The new syntax

Let's write some simple logic with a synchronous `Notifier`:

<AutoSnippet language="dart" {...buildIinit}></AutoSnippet>

Notice the following design choices:

- Notifiers are initialized in their `build` method, along with their reactive dependencies
- Notifiers expose `ref` into their class, whereas their Provider don't

### Comparison with `StateNotifier`

Let's compare the new APIs with the old ones; here, we implement the above example with `StateNotifier`:

```dart
class WellNotifier extends StateNotifier<int> {
  WellNotifier(int availableToDrink) : super(availableToDrink);

  void drink(int liters) => state = min(state - liters, 0);
}

final wellNotifierProvider = StateNotifierProvider<WellNotifier, int>((ref) {
  final availableToDrink = ref.watch(availableWater);
  return WellNotifier(availableToDrink);
});
```

Let's recap the main differences:

- `StateNotifier`'s reactive dependencies are declared in its provider, whereas `Notifier`
  centralizes this logic in its `build` method
- Indeed, `StateNotifier`'s whole initialization process is split between its provider and its constructor,
  whereas `Notifier` reserves a single place to place such logic
- Notice how, as opposed to `StateNotifier`, no logic is ever written into a `Notifier`'s constructor

Similar conclusions can be made with `AsyncNotifer`, `Notifier`'s asynchronous equivalent.  
Let's check it out.

## Better async support with `AsyncNotifier`

The main appeal of the new API syntax is an improved DX on asynchronous states.  
Previously, with `StateNotifier`, we would handle that like so:

```dart
class AsyncTodosNotifier extends StateNotifier<AsyncValue<List<Todo>>> {
  AsyncTodosNotifier() : super(const AsyncLoading()) {
    _postInit();
  }

  Future<void> _postInit() async {
    state = await AsyncValue.guard(
      // mock of a network request
      () => Future.delayed(const Duration(seconds: 1), () => []),
    );
  }

  // ...
}
```

This heavy syntax suffers from the same defects showed above.  
`AsyncNotifer`, just like `Notifier`, brings a simple and uniform API. Here, it's easy to see
`AsyncNotifer` as a `FutureProvider` with methods.

Here's the above example, rewritten with the new `AsyncNotifier` APIs:

<AutoSnippet language="dart" {...asyncNotifier}></AutoSnippet>

Therefore, migrating from `StateNotifier<AsyncValue<T>>` to a `AsyncNotifer<T>` should be very straightforward:

- Place the initialization logic directly into `build`: there's no need to define a `_postInit` method anymore
- There's no need to explicitly initialize `state` with `AsyncLoading`: as long as `build` returns a `Future`,
  this will be handled by `AsyncNotifer`, directly
- You can evaluate an initialization synchronously, if ever needed: just avoid returning a `Future` in your `build` method,
  i.e. let `build` be synchronous (this is the equivalent of initializing `StateNotifier` with an `AsyncData`)

Finally, `AsyncNotifer` comes with a set of utilities and getters that `StateNotifier` doesn't have, such as e.g.
[`future`](https://pub.dev/documentation/riverpod/latest/riverpod/AutoDisposeAsyncNotifier/future.html)
and [`update`](https://pub.dev/documentation/riverpod/latest/riverpod/AutoDisposeAsyncNotifier/update.html).
This enables us to write much simpler logic when handling asynchronous mutations.

## Explicit `.family` and `.autoDispose` modifications

When a `StateNotifier` had family parameters, these were not found into its class, but they were
defined in its provider; also, and chances are that these parameters must have been piped down its constructor, too.

`Notifier`, instead, has its own `.family` and `.autoDispose` counterparts, such as `FamilyNotifier`
and `AutoDisposeNotifier`.  
Like any other provider, these can be combined (aka `AutoDisposeFamilyNotifier`).  
`AsyncNotifer` has its asynchronous equivalent, too (e.g. `AutoDisposeFamilyAsyncNotifier`).

The main difference (and advantage) is that modifications and any parameters are explicitly stated inside the class;
furthermore, they are directly injected in the `build` method, so that they're available to the initialization logic.  
This should bring better readability, more conciseness and less mistakes.

Take the following example, in which a `StateNotifierProvider.family` is being defined.

```dart
class BugsEncounteredNotifier extends StateNotifier<AsyncValue<int>> {
  BugsEncounteredNotifier({
    required this.ref,
    required this.featureId,
  }) : super(const AsyncData(99));
  final String featureId;
  final Ref ref;

  Future<void> fix(int amount) async {
    state = await AsyncValue.guard(() async {
      final old = state.requireValue;
      final result = await ref.read(taskTrackerProvider).fix(id: featureId, fixed: amount);
      return max(old - result, 0);
    });
  }
}

final bugsEncounteredNotifierProvider =
    StateNotifierProvider.family.autoDispose<BugsEncounteredNotifier, int, String>((ref, id) {
  return BugsEncounteredNotifier(ref: ref, featureId: id);
});
```

The main gotcha here is that reading `BugsEncounteredNotifier` is _not_ enough to determine wheter or
not this `StateNotifier` has modifications (e.g. `.family` and/or `.autoDispose`).  
To determine that, it is required to read the its provider definition.

Now, let's take a look at its migrated `AsyncNotifier` counterpart:

<AutoSnippet language="dart" {...familyAndDispose}></AutoSnippet>

This last snippet should showcase better readability: it's possible to immediately tell
what modifications are being set for this Notifier.

## Lifecycles have a different behavior

Lifecycles between `Notifier`/`AsyncNotifier` and `StateNotifier`/`ChangeNotifier` differ substantially.

`StateNotifier` and `ChangeNotifier` instances are indeed bound to their outer
`StateNotifierProvider` and `ChangeNotifierProvider` providers.  
When their provider rebuilds, their exposed value, aka their `StateNotifier`/`ChangeNotifier` instance,
is `disposed`, and then re-created (i.e. its constructor gets invoked again).

This example showcases - again - how the old API have sparse logic:

```dart
class MyNotifier extends StateNotifier<int> {
  MyNotifier(this.period) : super(0) { // 1 init logic
    _timer = Timer.periodic(period, (t) => update());  // 2 side effect on init
  }
  final Duration period;
  late final Timer _timer;

  void update() => state++;  // 3 mutation

  @override
  void dispose() {
    _timer.cancel();  // 4 custom dispose logic
    super.dispose();
  }
}

final myNotifierProvider = StateNotifierProvider<MyNotifier, int>((ref) {  // 5 provider definition
  final Duration period = ref.watch(durationProvider);   // 6 reactive dependency logic
  return MyNotifier(period);
});
```

Here, if `durationProvider` updates, `MyNotifier` _disposes_: its instance is then re-instantiated
and its internal state is then re-initialized.  
Furthermore, unlike every other provider, the `dispose` callback is to be defined
in the class, separately.  
Finally, it is still possible to write `ref.onDispose` in its _provider_, showing once again how
sparse the logic can be with this API; potentially, the developer might have to look into six (6!)
different places to understand this Notifier behavior!

Again, this ambiguity is solved with `Riverpod 2.0`.
Check the above example, migrated to its `Notifier` equivalent.

<AutoSnippet language="dart" {...oldLifecycles}></AutoSnippet>

This simplifies the API and, hopefully, your DX, for two reasons:

1. There is only _one_ lifecycle to take care of, and it's managed via `ref.onDispose`
   (and `ref.onCancel`, etc.), just like you would do with any other provider
2. There is only _one_ place to look at to understand lifecycle side-effects, its `build` method
3. Also, the above `MyNotifier`, will _not_ dispose when `durationProvider` updates:
   only its _internal state_ will

### `.mounted` is no more

**TODO: talk about how there is no `.mounted` property and how to transition from it**

## Other migrations

Let's explore the less-impactful differences between `StateNotifier` and `Notifier` (or `AsyncNotifier`)

### From `.addListener` and `.stream`

`StateNotifier`'s `.addListener` and `.stream` can be used to listen for state changes.
These two APIs are now to be considered outdated.

This is intentional due to the desire to reach full API uniformity with `Notifier`, `AsyncNotifier` and other providers.  
Indeed, using a `Notifier` or an `AsyncNotifier` shouldn't be any different from any other provider.

Therefore this:
```dart
class MyNotifier extends StateNotifier<int> {
  MyNotifier() : super(0);

  void add() => state++;
}

final myNotifierProvider = StateNotifierProvider<MyNotifier, int>((ref) {
  final notifier = MyNotifier();

  final cleanup = notifier.addListener((state) => debugPrint('$state'));
  ref.onDispose(cleanup);

  // Or, equivalently:
  // final listener = notifier.stream.listen((event) => debugPrint('$event'));
  // ref.onDispose(listener.cancel);

  return notifier;
});
```
Becomes this:
<AutoSnippet language="dart" {...addListener}></AutoSnippet>

In a nutshell: if you want to listen to a `Notifier`/`AsyncNotifer`, just use `ref.listen`,
[as explained here](/docs/concepts/reading#using-reflisten-to-react-to-a-provider-change).

### From `.debugState`

`StateNotifier` exposed `.debugState`: this property had some use within `state_notifier`,
as it enabled accessing state from outside the class when in development mode, for testing purposes.

Again, for uniformity reasons, such property is not available in the new APIs.  
If you want to interact with `Notifier`/`AsyncNotifier` in a testing environment, you should do
it just like with any other provider: by reading them directly (as opposed of directly instantiating
a `Notifier` by hand).

The [testing guide](/docs/cookbooks/testing) fully explains how to use `ProviderContainer.read` to do so.

## From `StateProvider` to `Notifier`

`StateProvider` was exposed by Riverpod's libraries to save a few LoC when in need of a
simplified version of `StateNotifierProvider`.  
Since `StateNotifierProvider` is deprecated, `StateProvider` is to be avoided, too.  
Furthermore, as of now, there is not `StateProvider` equivalent for the new APIs.

Nonetheless, migrating from `StateProvider` to `Notifier` is simple.

This:

```dart
final counterProvider = StateProvider<int>((ref) {
  return 0;
});
```

Becomes:

<AutoSnippet language="dart" {...fromStateProvider}></AutoSnippet>

Even though it costs us a few more LoC, migrating away from `StateProvider` enables us to
definetively archive `StateNotifier`.

## From `ChangeNotifier` to `AsyncNotifier`

`ChangeNotifier` is meant to be used to offer a smooth transitionfrom pkg:Provider.  
This paragraphs showcases a migration towards the new APIs going further than what's showcased
in the [quickstart guide](/docs/from_provider/quickstart).

All in all, migrating from `ChangeNotifier` to `AsyncNotifer` requires a paradigm shift, but it
brings great simplification with the resulting migrated code.

Take this example:
```dart
class MyChangeNotifier extends ChangeNotifier {
  MyChangeNotifier() {
    _init();
  }
  List<Todo> todos = [];
  bool isLoading = true;
  bool hasError = false;

  Future<void> _init() async {
    try {
      // request mock
      todos = Future.delayed(const Duration(seconds: 1), () => <Todo>[]);
    } on Exception {
      hasError = true;
    } finally {
      isLoading = false;
      notifyListeners();
    }
  }

  Future<void> addTodo(int id) async {
    isLoading = true;
    notifyListeners();

    try {
      // request mock
      todos = Future.delayed(const Duration(seconds: 1), () => [Todo(id)]);
      hasError = false;
    } on Exception {
      hasError = true;
    } finally {
      isLoading = false;
      notifyListeners();
    }
  }
}

final myChangeProvider = ChangeNotifierProvider<MyChangeNotifier>((ref) {
  return MyChangeNotifier();
});
```

This implementation shows several faulty design choices such as:
- The usage of `isLoading` and `hasError` to handle different asynchronous cases
- The need to carefully handle requests with tedious `try`/`catch`/`finally` expressions
- The need to inkove `notifyListeners` at the right times to make this implementation work
- The presence of inconsistent or possibly undesirable states, e.g. initialization with an empty list

While this example has been crafted to show how `ChangeNotifier` can lead to faulty design choices
for newbie developers, the main takeaway is that mutable state might be harder than it looks.

`Notifier`/`AsyncNotifer`, in combination with immutable state, can lead to better design choices
and less errors; this approach lifts the developer from several intricacies due to the nature
of asynchronous state.

With `AsyncNotifier`, the above becomes:
<AutoSnippet language="dart" {...fromChangeNotifier}></AutoSnippet>

### Migration Process
Let's analyze the migration process applied here:
1. We've moved the initialization from a method invoked in a constructor, directly into `build`
2. We've removed `todos`, `isLoading` and `hasError`: `state` suffice
3. Notice how, since `build` returns a `Future<T>`, state is implicitly initialized with `AsyncLoading`,
waiting for the initial request to finish
4. We've returned the result of the (mocked) asynchronous request, with no try-catch-finally blocks
5. We've then simplified `addTodo`, exploiting `AsyncValue`'s APIs
6. Notice that, to apply mutations, we simply reassign `state` directly:
listeners will be automatically notified about it

### Advantages
Finally, let's highlight the main advantages of the new APIs:
- There's a lot less code, and what's left is way more simple and readable
- Since `AsyncNotifier` implicitly uses `AsyncValue`, there's no need to manually define and handle
 `isLoading` and `hasError`
- There's no need to explicitly handle errors (i.e. try-catch-finally blocks), since
`AsyncNotifier.build` converts errors into `AsyncError` and valid data into `AsyncData`
- `AsyncValue.guard` essentialy emulates `AsyncNotifier.build`, greatly simplifying mutations