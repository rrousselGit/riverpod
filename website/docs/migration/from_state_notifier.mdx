---
title: From `StateNotifier` and `ChangeNotifier`
---

import buildInit from "./from_state_notifier/build_init";
import buildInitOld from "./from_state_notifier/build_init_old";
import familyAndDispose from "./from_state_notifier/family_and_dispose";
import familyAndDisposeOld from "./from_state_notifier/family_and_dispose_old";
import asyncNotifier from "./from_state_notifier/async_notifier";
import asyncNotifierOld from "./from_state_notifier/async_notifier_old";
import addListener from "./from_state_notifier/add_listener";
import addListenerOld from "./from_state_notifier/add_listener_old";
import fromChangeNotifier from "./from_state_notifier/from_change_notifier";
import fromChangeNotifierOld from "./from_state_notifier/from_change_notifier_old";
import fromStateProvider from "./from_state_notifier/from_state_provider";
import fromStateProviderOld from "./from_state_notifier/from_state_provider_old";
import oldLifecycles from "./from_state_notifier/old_lifecycles";
import oldLifecyclesOld from "./from_state_notifier/old_lifecycles_old";
import consumersDontChange from "./from_state_notifier/consumers_dont_change";

import { AutoSnippet } from "../../src/components/CodeSnippet";

Along with [Riverpod 2.0](https://pub.dev/packages/flutter_riverpod/changelog#200), new classes
were introduced: `Notifier` / `AsyncNotifer`.  
The good old `StateNotifier` / `ChangeNotifier` classes are now discouraged in favor of those new APIs.

This page shows how to migrate from the deprecated `StateNotifier` (and from the legacy `ChangeNotifier`)
to the new APIs.

The main benefit introduced by `AsyncNotifier` is a better `async` support; indeed,
`AsyncNotifier` can be thought as a `FutureProvider` which can expose ways to be modified from the UI..

Furthermore, the new `(Async)Notifier`s:

- Expose a `Ref` object inside its class
- Offer similar syntax between codegen and non-codegen approaches
- Offer similar syntax between their sync and async versions
- Move away logic from Providers and centralize it into the Notifiers themselves

Let's see how to define a `Notifier`, how it compares with `StateNotifier` and how to migrate
the new `AsyncNotifier` for asynchronous state.

## Syntax comparison

Please read [how to define a `Notifier`](/docs/essentials/side_effects#defining-a-notifier) before
diving into this comparison.

Here's an example, using the old `StateNotifier`:
<AutoSnippet language="dart" {...buildInitOld}></AutoSnippet>

Here's the same example, but with the new `Notifier` APIs, which this translates to:
<AutoSnippet language="dart" {...buildInit}></AutoSnippet>


### Comparison with `StateNotifier`

Comparing `Notifier` with `StateNotifier`, one can observe these main differences:

- `StateNotifier`'s reactive dependencies are declared in its provider, whereas `Notifier`
  centralizes this logic in its `build` method
- `StateNotifier`'s whole initialization process is split between its provider and its constructor,
  whereas `Notifier` reserves a single place to place such logic
- Notice how, as opposed to `StateNotifier`, no logic is ever written into a `Notifier`'s constructor

Similar conclusions can be made with `AsyncNotifer`, `Notifier`'s asynchronous equivalent.  

## Migrating asynchronous `StateNotifier`s

The main appeal of the new API syntax is an improved DX on asynchronous data.  
Take the following example:

<AutoSnippet language="dart" {...asyncNotifierOld}></AutoSnippet>

Here's the above example, rewritten with the new `AsyncNotifier` APIs:

<AutoSnippet language="dart" {...asyncNotifier}></AutoSnippet>

`AsyncNotifer`, just like `Notifier`, brings a simpler and more uniform API.
Here, it's easy to see `AsyncNotifer` as a `FutureProvider` with methods.

Therefore, migrating from `StateNotifier<AsyncValue<T>>` to a `AsyncNotifer<T>` should be a matter of:

- Place the initialization logic directly into `build`: there's no need to define a `_postInit` method anymore
- Don't catch errors in the `build` method: they'll be converted to `AsyncError`, just like `AsyncValue.guard`
- There's no need to explicitly initialize `state` with `AsyncLoading`: when `build` returns a `Future`,
  its first state will be `AsyncLoading`; if it doesn't, its first state will be `AsyncData` or `AsyncError` (synchronously)

Finally, `AsyncNotifer` comes with a set of utilities and getters that `StateNotifier` doesn't have, such as e.g.
[`future`](https://pub.dev/documentation/riverpod/latest/riverpod/AutoDisposeAsyncNotifier/future.html)
and [`update`](https://pub.dev/documentation/riverpod/latest/riverpod/AutoDisposeAsyncNotifier/update.html).
This enables us to write much simpler logic when handling asynchronous mutations and
[side-effects](/docs/essentials/side_effects).

## Explicit `.family` and `.autoDispose` modifications

Another important difference is how families and auto dispose is handled with the new APIs.

`Notifier`, has its own `.family` and `.autoDispose` counterparts, such as `FamilyNotifier`
and `AutoDisposeNotifier`.  
As always, such modifications hese can be combined (aka `AutoDisposeFamilyNotifier`).  
`AsyncNotifer` has its asynchronous equivalent, too (e.g. `AutoDisposeFamilyAsyncNotifier`).

Modifications are explicitly stated inside the class; any parameters are directly injected in the
`build` method, so that they're available to the initialization logic.  
This should bring better readability, more conciseness and overall less mistakes.

Take the following example, in which a `StateNotifierProvider.family` is being defined.

<AutoSnippet language="dart" {...familyAndDisposeOld}></AutoSnippet>

`BugsEncounteredNotifier` feels... heavy / hard to read.  
Let's take a look at its migrated `AsyncNotifier` counterpart:

<AutoSnippet language="dart" {...familyAndDispose}></AutoSnippet>

Its migrated counterpart should feel like a light read.

:::info
`(Async)Notifier`'s `.family` parameters are available via `this.arg` (or `this.paramName` when using codegen)
:::

## Lifecycles have a different behavior

Lifecycles between `Notifier`/`AsyncNotifier` and `StateNotifier`/`ChangeNotifier` differ substantially.

`StateNotifier` and `ChangeNotifier` instances are indeed bound to their outer
`StateNotifierProvider` and `ChangeNotifierProvider` providers.  
When their provider rebuilds, their exposed value, aka their `StateNotifier`/`ChangeNotifier` instance,
is `disposed`, and then re-created (i.e. its constructor gets invoked again).

This example showcases - again - how the old API have sparse logic:

<AutoSnippet language="dart" {...oldLifecyclesOld}></AutoSnippet>

Here, if `durationProvider` updates, `MyNotifier` _disposes_: its instance is then re-instantiated
and its internal state is then re-initialized.  
Furthermore, unlike every other provider, the `dispose` callback is to be defined
in the class, separately.  
Finally, it is still possible to write `ref.onDispose` in its _provider_, showing once again how
sparse the logic can be with this API; potentially, the developer might have to look into six (6!)
different places to understand this Notifier behavior!

Again, this ambiguity is solved with `Riverpod 2.0`.
Check the above example, migrated to its `Notifier` equivalent.

<AutoSnippet language="dart" {...oldLifecycles}></AutoSnippet>

This simplifies the API and, hopefully, your DX, for two reasons:

1. There is only _one_ lifecycle to take care of, and it's managed via `ref.onDispose`
   (and `ref.onCancel`, etc.), just like you would do with any other provider
2. There is only _one_ place to look at to understand lifecycle side-effects, its `build` method
3. Also, the above `MyNotifier`, will _not_ dispose when `durationProvider` updates:
   only its _internal state_ will

## Mutations APIs are the same as before

Up until now we've shown the differences between `StateNotifier` and the new APIs.  
Instad, one thing `Notifier`, `AsyncNotifer` and `StateNotifier` share is how their states
can be consumed and mutated.

Consumers can obtain data from these three providers with the same syntax, which is great in case
you're migrating away from `StateNotifier`, and this applies for notifiers methods, too.

<AutoSnippet language="dart" {...consumersDontChange}></AutoSnippet>

## Other migrations

Let's explore the less-impactful differences between `StateNotifier` and `Notifier` (or `AsyncNotifier`)

### From `.addListener` and `.stream`

`StateNotifier`'s `.addListener` and `.stream` can be used to listen for state changes.
These two APIs are now to be considered outdated.

This is intentional due to the desire to reach full API uniformity with `Notifier`, `AsyncNotifier` and other providers.  
Indeed, using a `Notifier` or an `AsyncNotifier` shouldn't be any different from any other provider.

Therefore this:
<AutoSnippet language="dart" {...addListenerOld}></AutoSnippet>

Becomes this:
<AutoSnippet language="dart" {...addListener}></AutoSnippet>

In a nutshell: if you want to listen to a `Notifier`/`AsyncNotifer`, just use `ref.listen`,
[as explained here](/docs/concepts/reading#using-reflisten-to-react-to-a-provider-change).

### From `.debugState`

`StateNotifier` exposed `.debugState`: this property had some use within `state_notifier`,
as it enabled accessing state from outside the class when in development mode, for testing purposes.

Again, for uniformity reasons, such property is not available in the new APIs.  
If you want to interact with `Notifier`/`AsyncNotifier` in a testing environment, you should do
it just like with any other provider: by reading them directly (as opposed of directly instantiating
a `Notifier` by hand).

The [testing guide](/docs/cookbooks/testing) fully explains how to use `ProviderContainer.read` to do so.

### From `StateProvider` to `Notifier`

`StateProvider` was exposed by Riverpod since its release, and it was made to save a few LoC for
simplified versions of `StateNotifierProvider`.  
Since `StateNotifierProvider` is deprecated, `StateProvider` is to be avoided, too.  
Furthermore, as of now, there is no `StateProvider` equivalent for the new APIs.

Nonetheless, migrating from `StateProvider` to `Notifier` is simple.

This:
<AutoSnippet language="dart" {...fromStateProviderOld}></AutoSnippet>

Becomes:
<AutoSnippet language="dart" {...fromStateProvider}></AutoSnippet>

Even though it costs us a few more LoC, migrating away from `StateProvider` enables us to
definetively archive `StateNotifier`.

## From `ChangeNotifier` to `AsyncNotifier`

`ChangeNotifier` is meant to be used to offer a smooth transitionfrom pkg:provider.  
This paragraphs showcases a migration towards the new APIs going further than what's showcased
in the [quickstart guide](/docs/from_provider/quickstart).

All in all, migrating from `ChangeNotifier` to `AsyncNotifer` requires a paradigm shift, but it
brings great simplification with the resulting migrated code.

Take this example:
<AutoSnippet language="dart" {...fromChangeNotifierOld}></AutoSnippet>

This implementation shows several faulty design choices such as:
- The usage of `isLoading` and `hasError` to handle different asynchronous cases
- The need to carefully handle requests with tedious `try`/`catch`/`finally` expressions
- The need to inkove `notifyListeners` at the right times to make this implementation work
- The presence of inconsistent or possibly undesirable states, e.g. initialization with an empty list

While this example has been crafted to show how `ChangeNotifier` can lead to faulty design choices
for newbie developers, the main takeaway is that mutable state might be harder than it looks.

`Notifier`/`AsyncNotifer`, in combination with immutable state, can lead to better design choices
and less errors; this approach lifts the developer from several intricacies due to the nature
of asynchronous state.

With `AsyncNotifier`, the above becomes:
<AutoSnippet language="dart" {...fromChangeNotifier}></AutoSnippet>

### Migration Process
Let's analyze the migration process applied here:
1. We've moved the initialization from a method invoked in a constructor, directly into `build`
2. We've removed `todos`, `isLoading` and `hasError`: `state` suffice
3. Notice how, since `build` returns a `Future<T>`, state is implicitly initialized with `AsyncLoading`,
waiting for the initial request to finish
4. We've returned the result of the asynchronous request, with no try-catch-finally blocks
5. We've then simplified `addTodo`, exploiting `AsyncValue`'s APIs
6. Notice that, to apply mutations, we simply reassign `state` directly:
listeners will be automatically notified about it

### Advantages
Finally, let's highlight the main advantages of the new APIs:
- There's a lot less code, and what's left is way more simple and readable
- Since `AsyncNotifier` implicitly uses `AsyncValue`, there's no need to manually define and handle
 `isLoading` and `hasError`
- There's no need to explicitly handle errors (i.e. try-catch-finally blocks), since
`AsyncNotifier.build` converts errors into `AsyncError` and valid data into `AsyncData`
- `AsyncValue.guard` essentialy emulates `AsyncNotifier.build`, greatly simplifying mutations