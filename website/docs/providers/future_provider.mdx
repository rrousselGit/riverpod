---
title: FutureProvider
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import CodeBlock from "@theme/CodeBlock";
import todo from "!!raw-loader!/docs/providers/provider/todo.dart";
import { trimSnippet } from "../../src/components/CodeSnippet";

`FutureProvider` is the equivalent of [Provider] from asynchronous code.

`FutureProvider` is typically used for:

- performing and caching asynchronous operations (such as network requests)
- nicely handling error/loading states of asynchronous operations
- combining multiple asynchronous values into another value.

`FutureProvider` gains a lot in combining it with [ref.watch]. This combination
allows automatic re-fetching of some data when some variables change,
ensuring that we always have the most up-to-date value.

:::caution
`FutureProvider` does not offer a way of directly modifying the computation after
a user interaction. It is designed to solve simple use-cases.  
For more advanced scenarios, consider using [StateNotifierProvider].
:::

## Usage example: reading a configuration file

`FutureProvider` can be a convenient way to expose a `Configuration` object
created by reading a JSON file.

Creating the configuration would be done with your typical async/await
syntax, but inside the provider.
Using Flutter's asset system, this would be:

```dart
final configProvider = FutureProvider<Configuration>((ref) async {
  final content = json.decode(
    await rootBundle.loadString('assets/configurations.json'),
  ) as Map<String, Object?>;

  return Configuration.fromJson(content);
});
```

Then, the UI can listen to configurations like so:

```dart
Widget build(BuildContext context, WidgetRef ref) {
  AsyncValue<Configuration> config = ref.watch(configProvider);

  return config.when(
    loading: () => const CircularProgressIndicator(),
    error: (err, stack) => Text('Error: $err'),
    data: (config) {
      return Text(config.host);
    },
  );
}
```

This will automatically rebuild the UI when the [Future] completes.
At the same time, if multiple widgets want the configurations,
the asset will be decoded only once.

As you can see, listening to a `FutureProvider` inside a widget returns
an [AsyncValue] â€“ which allows handling the error/loading states.

[ref.watch]: ../concepts/reading#using-refwatch-to-observe-a-provider
[statenotifierprovider]: ./state_notifier_provider
[provider]: ./provider
[asyncvalue]: https://pub.dev/documentation/riverpod/latest/riverpod/AsyncValue-class.html
[future]: https://api.dart.dev/dart-async/Future-class.html
[family]: ../concepts/modifiers/family
