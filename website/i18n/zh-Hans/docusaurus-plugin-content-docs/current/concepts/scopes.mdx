---
title: 作用域
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import CodeBlock from "@theme/CodeBlock";
import asyncInitialization from "!!raw-loader!/docs/concepts/async_initialization.dart";
import dialogScope from "!!raw-loader!/docs/concepts/dialog_scope.dart";
import themeScope from "!!raw-loader!/docs/concepts/theme_scope.dart";
import subtreeScope from "!!raw-loader!/docs/concepts/subtree_scope.dart";
import { trimSnippet } from "../../../../../src/components/CodeSnippet";

Riverpod 中的作用域是一个非常强大的功能，但像其他强大的功能一样，应该理智地使用它。

作用域支持：
- 覆盖特定子树的 provider 状态（类似于主题和 `InheritedWidgets` 在 flutter 中的工作方式）[【查看示例】](#子树作用域)
- 为一般异步 API 创建同步 provider [【查看示例】](#%E5%BC%82%E6%AD%A5-api-%E7%9A%84%E5%90%8C%E6%AD%A5-provider-%E5%88%9D%E5%A7%8B%E5%8C%96)
- 允许 `Dialog` 和 `Overlay` 从 widget 子树继承 provider 的状态以显示它们。[【查看示例】](#展示对话框)
- 通过从 widget 的构造函数中删除参数来优化 widget 的重建，从而允许你将它们设置为 `const`

如果你想用作用域来表示上面的第一点，你也可以用 family 来代替。

family 的优点是允许你从 widget 树中的任何位置访问状态的每个实例，而不仅仅是从你所在的特定子树的状态范围访问。

但是，使用作用域来完成该任务的限制更大，因为你不能决定从该作用域访问其他实例。

因此，在确定所使用的每个 provider 的作用域之前，请仔细考虑为什么要确定 provider 的作用域。

## ProviderScope 和 ProviderContainer

作用域由 [ProviderContainer] 引入。这个容器保存了所有 provider 的当前状态。它管理 provider 之间的查找和订阅功能。

在Flutter中，你应该使用 [ProviderScope] widget，
它内部包含一个 [ProviderContainer]，并提供了一种访问该容器到 widget 树其余部分的方法。

```dart
final valueProvider = StateProvider((ref) => 0);

// 这样做：
void main() {
  runApp(ProviderScope(child: MyApp()));
}

// 不要这样做：
final myProviderContainer = ProviderContainer();
void main(){
  runApp(MyApp());
}
```

:::warning
在了解它们的工作原理之前，不要使用多个 [ProviderContainer]。

每个线程都有自己独立的状态线程，这些状态线程不能相互访问。

就比如你测试的时候可能想使用单独的 [ProviderContainer]，以便使每个测试的状态独立于其他测试。
:::

在纯 Dart 项目中和测试过程中创建并使用 [ProviderContainer] 即可，不需要 [ProviderScope]。

## Riverpod 是如何找到一个 Provider 的

当一个 widget 或 provider 请求一个 provider 的值时，Riverpod 在最近的 ProviderScope widget 中查找该 provider 的状态。如果 provider 和它显式列出的依赖项都没有在该范围内被覆盖到，Riverpod 将继续查找 widget 树。如果 provider 没有在任何 widget 子树中被覆盖到，则默认查找到根 [ProviderScope] 中的 [ProviderContainer]。

一旦该进程定位了 provider 应该驻留的作用域，它就会确定 provider 是否已经创建。如果是，它将返回 provider 的状态。但是如果 provider 已经失效或未初始化，它将使用 provider 的构建方法创建状态。

## 异步 API 的同步 provider 初始化

通常，你可能会对如 `SharedPreferences` 或 `FirebaseApp` 的依赖项进行一些异步初始化。其他的 provider 可能依赖于此，在每个 provider 中处理错误/加载中状态是多余的。

你可以保证这些 provider 不会有错误，并且在应用启动时可以快速加载。

那么，如何让这些 provider 状态同步可用呢？

下面是一个示例，它展示了当异步 API 准备好时，作用域如何允许你覆盖一个形式上的 provider。

<CodeBlock>{trimSnippet(asyncInitialization)}</CodeBlock>

## 展示对话框

当你显示一个 `Dialog` 或 `OverlayEntry` 时，Flutter 会创建一个新的 `Route` 或添加到具有不同构建范围的 `Overlay` 中，这样它就可以摆脱它的父布局，并可以显示在其他 `Routes` 之上。
但这通常会给 `InheritedWidget` 带来一个问题，因为 [ProviderScope] 也是一个 `InheritedWidget`，所以它也会受到影响。

为了解决这个问题，Riverpod 允许你创建一个 `ProviderScope`，它可以访问父作用域中所有 provider 的状态。

下面的示例展示了如何使用这个功能，它允许打开的 `Dialog` 从 `context` 中访问计数器的状态。

<CodeBlock>{trimSnippet(dialogScope)}</CodeBlock>

## 子树作用域

作用域允许你覆盖 widget 树的特定子树的 provider 状态。

通过这种方式，它可以提供类似于 flutter 中的 `InheritedWidget` 或 `package:provider` 中的 provider 机制。

比如，在 flutter 中，通过将 widget 树的特定子树包装在 Theme widget 中，可以覆盖 widget 树的 Theme。

<CodeBlock>{trimSnippet(themeScope)}</CodeBlock>

在底层，`Theme` 是一个 `InheritedWidget`，当 widget 查找 `Theme` 时，它们从 widget 树中找到最近的 `Theme` widget 来获得主题。

Riverpod 的工作方式不太一样，因为应用的所有状态通常存储在根 [ProviderScope] widget中。

不要担心，当状态改变时，这不会导致整个应用程序重新构建，它只是允许你从 widget 树中的任何位置去访问状态。

如果根据所处的页面需要不同的 provider 该怎么办?

你应该考虑的第一件事是它所提供的行为是否会以某种方式有所不同。

如果不同 -> 只需创建一个不同名称的新的 provider，并在该页面中使用它

如果相同 -> 考虑使用 family[【在这里了解更多关于 family 的内容】](/docs/concepts/modifiers/family)。

通常，你开始时认为只需要在特定页面上使用 provider，但最后却希望在稍后的另一个页面上也使用它。

family 可以让你不受这种可能性的影响，如果你是来自 `package:provider` 的开发者，你应该使用 family 来调整思维。

但如果 family 确实不适合你的用例，下面的示例向你展示了如何覆盖特定子树的 provider：

<CodeBlock>{trimSnippet(subtreeScope)}</CodeBlock>

## 什么时候选择有作用域的 Provider 还是 Family

虽然理解作用域很重要，但在使用作用域时很容易失去控制。

如果你想要一个 provider 状态的不同实例，取决于它在 widget 树中的位置，你有几个可供选择的选项: `Scoping`、`Families`，或组合它们。

请根据你的情况选择合适方案。

Families：
- 优点：无论你在哪个子树中，你都可以显示多个状态
- 优点：这使得它成为许多用例的更灵活和可扩展的解决方案

作用域:
- 缺点：你最终会在你的 widget 树中嵌套更多的 [ProviderScope] widget
- 缺点：你只能访问一个覆盖住你部分的 widget 树
- 缺点：你最终不得不显式地列出大多数 provider 的依赖关系
- 优点：可以减少 widget 构造函数中的参数数量
- 优点：你可以获得轻微的性能优势，并且可以潜在地使你的一些 widget 的构造函数为 const

组合使用这两种方法，你可以同时获得这两种方法的优点，但你仍然必须解决作用域的缺点。

:::warning
请记住，作用域为每个被覆盖的 provider 或列出了对被覆盖的 provider 的依赖项的 provider 引入了一个新的状态实例。

如果你在应用程序的不同子树中覆盖相同的参数，它将 **不会是** provider 状态的相同实例。

一般来说，family 更加灵活，并且通过即将到来的代码生成特性，可以很容易地为一个 family 使用多个参数。

一个很好的组合通常是同时使用 family 和作用域。使用一个 family 来提供对应用中任何地方的状态块的访问，取决于你在 widget 树中的位置，然后使用作用域来提供一个特定的 family 状态实例。
:::

### 作用域的不常见用法

有时你可能想要覆盖应用特定子树中的所有 provider。通过在每个 provider 的依赖项列表中列出一个公共 provider，你可以通过覆盖公共 provider 轻松地一次性为所有这些 provider 创建新状态。

请注意，如果你尝试使用 family 来实现此功能，那么你将得到许多具有相同参数的family，并且你可能会在整个 widget 树中传递该参数。在这种情况下，也可以使用作用域。

:::warning
一旦开始使用作用域，请确保始终列出依赖项并保持最新状态，以防止运行时异常。

为了解决这个问题，我们创建了 [riverpod_lint]，它会在缺少依赖时警告你。

另外，使用 [riverpod_generator] 这个代码生成器会自动为你生成依赖项列表。
:::

[ProviderContainer]: https://pub.dev/documentation/riverpod/latest/riverpod/ProviderContainer-class.html
[ProviderScope]: https://pub.dev/documentation/flutter_riverpod/latest/flutter_riverpod/ProviderScope-class.html
[riverpod_lint]: https://github.com/rrousselGit/riverpod/tree/master/packages/riverpod_lint
[riverpod_generator]: https://github.com/rrousselGit/riverpod/tree/master/packages/riverpod_generator
