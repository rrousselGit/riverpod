---
title: 为什么选择 Riverpod？
version: 1
---

import whyRiverpod from "./why_riverpod";
import { AutoSnippet } from "@site/src/components/CodeSnippet";

<!---
## What is Riverpod?
-->
## 什么是 Riverpod？

<!---
Riverpod (anagram of [Provider](https://pub.dev/packages/provider)) is a reactive
caching framework for Flutter/Dart.
-->
Riverpod（[Provider](https://pub.dev/packages/provider) 的异序词）是 Flutter/Dart 的反应式缓存框架。

<!---
Using declarative and reactive programming, Riverpod takes care of
a large part of your application's logic for you. It can perform network-requests
with built-in error handling and caching, while automatically re-fetching
data when necessary.
-->
Riverpod 使用声明式和反应式编程，为您处理应用程序的大部分逻辑。
它可以通过内置的错误处理和缓存来执行网络请求，同时在必要时自动重新获取数据。

<!---
## Motivation
-->
## 动机

<!---
Modern applications rarely come with all the information necessary to render
their User Interface. Instead, the data is often fetched asynchronously
from a server.
-->
现代应用程序很少提供呈现其用户界面所需的所有信息。
相反，数据通常是从服务器异步获取的。

<!---
The problem is, working with asynchronous code is hard. Although Flutter comes
with some way to create state variables and refresh the UI on change, it is still
fairly limited. A number of challenges remain unsolved:
-->
问题是，使用异步代码很困难。
尽管 Flutter 提供了一些创建状态变量并在更改时刷新 UI 的方法，但它仍然相当有限。
许多挑战仍未解决：

<!---
- Asynchronous requests need to be cached locally, as it would be unreasonable
  to re-execute them whenever the UI updates.
- Since we have a cache, our cache could get out of date if we're not careful.
- We also need to handle errors and loading states
-->
- 异步请求需要在本地缓存，因为每当 UI 更新时就重新执行异步请求是不合理的。
- 由于我们有一个缓存，如果我们不关心的话，我们的缓存可能会过时。
- 我们还需要处理错误和加载状态。

<!---
Nailing those problems at scale can be difficult, and they are impacted by a large
amount of features, such as:
-->
大规模解决这些问题可能很困难，并且它们会受到大量功能的影响，例如：

<!---
- pull to refresh
- infinite lists / fetch as we scroll
- search as we type
- debouncing asynchronous requests
- cancelling asynchronous requests when no-longer used
- optimistic UIs
- offline mode
- ...
-->
- 下拉刷新
- 无限列表/上划加载
- 键入时搜索
- 对异步请求进行去抖动
- 不再使用异步请求时取消异步请求
- 乐观 UI （注：主动积极的更新 UI 以实现良好的用户体验）
- 离线模式
- ……

<!---
These features can be tricky to implement, but are crucial for a good user experience.  
Yet few packages try to tackle those problems directly, and a lot of the work
has to be done manually.
-->
这些功能可能很难实现，但对于良好的用户体验至关重要。  
然而，很少有软件包尝试直接解决这些问题，而且很多工作必须手动完成。

<!---
That's where Riverpod comes in.  
Riverpod tries to solve those problems, by offering a new unique
way of writing business logic, inspired by Flutter widgets. In
many ways Riverpod is comparable to widgets, but for state.
-->
这就是 Riverpod 的用武之地。  
Riverpod 试图通过提供一种新的、独特的业务逻辑编写方式来解决这些问题，
这种方式的灵感来自 Flutter 小部件。
在许多方面，Riverpod 可以与小部件相媲美，但仅限于状态管理。

<!---
Using this new approach, these complex features are mostly done by default. All
that's left is to focus on your UI.
-->
使用这种新方法，这些复杂的功能大多是默认完成的。
剩下的就是专注于你的 UI。

<!---
Skeptical? Here's an example. The following snippet is a simplification of the [Pub.dev](https://github.com/rrousselGit/riverpod/tree/master/examples/pub)
client application implemented using Riverpod.
-->
不信？举个例子。
以下代码片段是使用 Riverpod 实现的 Pub.dev 客户端应用程序的简化版本。

<AutoSnippet language="dart" {...whyRiverpod}></AutoSnippet>

<!---
This snippet is all the business logic you need for a "search as we type" +
"pull to refresh" + "infinite list", while handling error/loading states.
-->
此代码片段是在处理错误/加载状态时，“键入时搜索”+“下拉刷新”+“无限列表”所需的所有业务逻辑。
