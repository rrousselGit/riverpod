---
title: Scopes
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import CodeBlock from "@theme/CodeBlock";
<<<<<<< HEAD
import asyncInitialization from "!!raw-loader!/docs/concepts/async_initialization.dart";
import dialogScope from "!!raw-loader!/docs/concepts/dialog_scope.dart";
import themeScope from "!!raw-loader!/docs/concepts/theme_scope.dart";
import subtreeScope from "!!raw-loader!/docs/concepts/subtree_scope.dart";
import { trimSnippet } from "../../src/components/CodeSnippet";

Le scoping dans Riverpod est une fonctionnalité très puissante, mais comme toute fonctionnalité puissante, elle doit être utilisée à bon escient et intentionnellement.
Here are some of the things that framing allows:
- Remplace l'état des providers pour un sous-arbre spécifique (similaire à la façon dont les thèmes et les `InheritedWidgets` fonctionnent dans flutter) [(voir exemple)](#subtree-scope)
- Création de providers synchrones pour des API normalement asynchrones [(voir exemple)](#initialization-of-synchronous-provider-for-async-apis)
- Permettre aux `Dialogs` et `Overlay` d'hériter de l'état des providers du sous-arbre widget qui les font apparaître [(voir exemple)](#showing-dialogs)
- Optimisation des reconstructions de widgets en supprimant les paramètres des constructeurs de widgets, ce qui vous permet de les rendre `const`.

Si vous voulez utiliser scope pour le premier point, il y a de fortes chances que vous puissiez utiliser les familles à la place.
Les familles ont l'avantage de vous permettre d'accéder à chacune de ces instances de l'état à partir de n'importe quel endroit de l'arborescence du widget, plutôt que d'accéder uniquement à l'état correspondant à la sous-arborescence spécifique dans laquelle vous vous trouvez.

L'utilisation de la portée (scope) pour créer plusieurs instances de l'état d'un provider est similaire au fonctionnement de `package:provider`.

Toutefois, l'utilisation de la portée (scope) pour accomplir cette tâche est plus restrictive, car vous ne pouvez pas décider d'accéder à d'autres instances à partir de cette portée.

Ainsi, avant de procéder à l'évaluation de chaque provider que vous utilisez, réfléchissez bien aux raisons pour lesquelles vous souhaitez l'évaluer.
=======
import asyncInitialization from "!!raw-loader!/i18n/fr/docusaurus-plugin-content-docs/current/concepts/async_initialization.dart";
import dialogScope from "!!raw-loader!/i18n/fr/docusaurus-plugin-content-docs/current/concepts/dialog_scope.dart";
import themeScope from "!!raw-loader!/i18n/fr/docusaurus-plugin-content-docs/current/concepts/theme_scope.dart";
import subtreeScope from "!!raw-loader!/i18n/fr/docusaurus-plugin-content-docs/current/concepts/subtree_scope.dart";
import { trimSnippet } from "../../../../../src/components/CodeSnippet";

Le scoping dans Riverpod est une fonctionnalité très puissante, mais comme toute fonctionnalité puissante, elle doit être utilisée à bon escient et intentionnellement.

Voici quelques-unes des possibilités offertes par le scoping :
- Remplacer l'état des providers pour un sous-arbre spécifique (similaire à la façon dont les thèmes et les `InheritedWidgets` fonctionnent dans flutter)[(voir exemple)](#scoping-de-sous-arbres)
- Création de providers synchrones pour des API normalement asynchrones [(voir exemple)](#initialization-of-synchronous-provider-for-async-apis)
- Permettre aux `Dialogs` et aux `Overlay`s d'hériter de l'état des providers du sous-arbre du widget qui les font apparaître [(voir exemple)](#affichage-des-dialogues)
- Optimisation des reconstructions de widgets en supprimant les paramètres des constructeurs de widgets, ce qui vous permet de les rendre `const`.

Si vous voulez utiliser le scope pour le premier point, il y a de fortes chances que vous puissiez utiliser les familles à la place.
Les familles ont l'avantage de vous permettre d'accéder à chacune de ces instances de l'état à partir de n'importe quel endroit de l'arbre des widgets, plutôt que d'accéder uniquement à l'état correspondant au sous-arbre spécifique dans lequel vous vous trouvez.

L'utilisation de la portée pour créer plusieurs instances de l'état d'un provider est similaire à la façon dont le `package:provider` fonctionne.

Cependant, l'utilisation de la portée pour accomplir cette tâche est plus restrictive, car vous ne pouvez pas décider d'accéder à d'autres instances à partir de cette portée.

En tant que tel, avant de définir la portée de chaque provider que vous utilisez, réfléchissez bien à la raison pour laquelle vous voulez définir la portée du provider.
>>>>>>> 01f66c936e312493a4bf6ef40a9254827c7eed99

## ProviderScope et ProviderContainer

Un scope est introduit par un [ProviderContainer]. Ce conteneur contient l'état actuel de tous vos providers. 
Il gère la recherche et les abonnements entre les providers.

<<<<<<< HEAD
Dans Flutter, vous devez utiliser le widget [ProviderScope], qui contient un [ProviderContainer]
en interne, et fournit un moyen d'accéder à ce conteneur dans le reste de l'arborescence des widgets.
=======
Dans Flutter, il convient d'utiliser le widget [ProviderScope], qui contient un [ProviderContainer]
en interne, et fournit un moyen d'accéder à ce conteneur au reste de l'arborescence du widget.
>>>>>>> 01f66c936e312493a4bf6ef40a9254827c7eed99

```dart
final valueProvider = StateProvider((ref) => 0);

<<<<<<< HEAD
// DO this
=======
// FAITES ceci
>>>>>>> 01f66c936e312493a4bf6ef40a9254827c7eed99
void main() {
  runApp(ProviderScope(child: MyApp()));
}

<<<<<<< HEAD
//DON'T do this:
=======
// Ne FAITES PAS ceci
>>>>>>> 01f66c936e312493a4bf6ef40a9254827c7eed99
final myProviderContainer = ProviderContainer();
void main(){
  runApp(MyApp());
}
```

:::warning
N'utilisez pas plusieurs [ProviderContainer] sans savoir comment ils fonctionnent. 
<<<<<<< HEAD
Chacun aura son propre fil d'états, qui ne pourra pas accéder aux autres.
Les tests sont un exemple de cas où il est préférable d'utiliser des [ProviderContainer] séparés afin de rendre l'état de chaque test indépendant des autres.
=======
Chacun aura son propre fil d'états séparé, qui ne pourra pas accéder aux autres.
Les tests sont un exemple de cas où vous pouvez utiliser des [ProviderContainer] séparés
distincts afin de rendre l'état de chaque test indépendant des autres.
>>>>>>> 01f66c936e312493a4bf6ef40a9254827c7eed99
:::

Ne créez un [ProviderContainer] sans [ProviderScope] qu'à des fins de test et pour un usage exclusif.

## Comment Riverpod trouve un Provider

Lorsqu'un widget ou un provider demande la valeur d'un provider, Riverpod recherche l'état de ce provider dans le widget [ProviderScope] le plus proche. 
<<<<<<< HEAD
Le widget [ProviderScope] le plus proche. Si ni le provider ni l'une de ses dépendances explicitement listées ne sont remplacés dans cette portée, Riverpod poursuit sa recherche dans l'arbre des widgets. 
=======
Si ni le provider ni l'une de ses dépendances explicitement listées ne sont remplacés dans cette portée, Riverpod poursuit sa recherche dans l'arbre des widgets. 
>>>>>>> 01f66c936e312493a4bf6ef40a9254827c7eed99
Si le provider n'a été remplacé dans aucun sous-arbre de widget, la recherche se fait par défaut sur le [ProviderContainer] dans le [ProviderScope] racine.

Une fois que ce processus a localisé l'étendue dans laquelle le provider doit résider, il détermine si le provider a déjà été créé. 
Si c'est le cas, il renvoie l'état du provider.
Toutefois, si le provider a été invalidé ou n'est pas encore initialisé, il créera l'état en utilisant la méthode de construction du provider.

<<<<<<< HEAD
## Initialisation d'un provider synchrone pour les API asynchrones

Souvent, vous pouvez avoir une initialisation asynchrone d'une dépendance telle que `SharedPreferences` ou `FirebaseApp`.
De nombreux autres providers peuvent s'appuyer sur cette dépendance, et gérer les états d'erreur/chargement dans chacun de ces providers est redondant.

Vous pourriez garantir que ces providers n'auront pas d'erreurs et qu'ils se chargeront rapidement au démarrage de l'application.

Alors comment faire pour que ces sortes d'états de providers soient disponibles de manière synchrone ?
=======
## Initialisation de Provider Synchrone pour les API Asynchrones

Souvent, vous pouvez avoir une initialisation asynchrone d'une dépendance telle que `SharedPreferences` ou `FirebaseApp`.
De nombreux autres providers peuvent s'appuyer sur cette dépendance, et la gestion des états d'erreur et de chargement de chacun de ces providers est redondante.

Vous pourriez être en mesure de garantir que ces providers n'auront pas d'erreurs et se chargeront rapidement au démarrage de l'application.

Alors comment faire pour que ce genre d'états de provider soit disponible de manière synchrone ?
>>>>>>> 01f66c936e312493a4bf6ef40a9254827c7eed99

Voici un exemple qui montre comment le scoping vous permet de remplacer un provider fictif lorsque votre API asynchrone est prête.

<CodeBlock>{trimSnippet(asyncInitialization)}</CodeBlock>

<<<<<<< HEAD
## Affichage des boîtes de dialogue

Lorsque vous affichez un `Dialog` ou un `OverlayEntry`, flutter crée une nouvelle `Route` ou ajoute à un `Overlay` qui a une portée de construction différente, 
afin qu'il puisse échapper à la mise en page de son parent, et qu'il puisse être affiché au-dessus des autres `Routes`. 
Cela pose un problème pour les `InheritedWidget`s en général, et comme [ProviderScope] est un `InheritedWidget`, il est également concerné.

Pour résoudre ce problème, Riverpod vous permet de créer un `ProviderScope` qui peut accéder à l'état de tous les providers dans un scope `parent`.

L'exemple suivant montre comment l'utiliser, pour permettre à une `Dialog` d'accéder à l'état d'un compteur depuis le contexte qui a provoqué l'affichage de la `Dialog`.

<CodeBlock>{trimSnippet(dialogScope)}</CodeBlock>

## Portée du sous-arbres

Le scoping vous permet de surcharger l'état d'un provider pour un sous-arbre spécifique de votre arbre de widgets. De cette façon, 
il peut fournir un mécanisme similaire à `InheritedWidget` de flutter, ou les providers de `package:provider`.

Par exemple, dans flutter, vous pouvez remplacer le `Theme` d'un sous-arbre particulier de votre arbre de widgets, en l'enveloppant dans un widget `Theme`.

=======
## Affichage des dialogues

Lorsque vous affichez un `Dialog` ou un `OverlayEntry`, flutter crée une nouvelle `Route` ou ajoute à un `Overlay` qui a une portée de construction différente,
afin qu'il puisse échapper à la disposition de son parent, et qu'il puisse être affiché au-dessus des autres `Routes`. 
Cela pose un problème pour les `InheritedWidget`s en général, et comme [ProviderScope] est un `InheritedWidget`, il est également affecté.

Pour résoudre ce problème, Riverpod vous permet de créer un `ProviderScope` qui peut accéder à l'état de tous les providers dans une portée `parent`.

L'exemple suivant montre comment l'utiliser, pour permettre à un `Dialog` d'accéder à l'état d'un compteur depuis le contexte qui a provoqué l'affichage du `Dialog`.
<CodeBlock>{trimSnippet(dialogScope)}</CodeBlock>

## Scoping de sous-arbres

Le scoping vous permet de surcharger l'état d'un provider pour un sous-arbre spécifique de votre arbre de widgets. 
De cette façon, il peut fournir un mécanisme similaire à `InheritedWidget` de flutter, ou les providers du `package:provider`.

Par exemple, dans flutter, vous pouvez remplacer le `Theme` pour un sous-arbre particulier de votre arbre de widgets, en l'enveloppant dans un widget `Theme`.
>>>>>>> 01f66c936e312493a4bf6ef40a9254827c7eed99
<CodeBlock>{trimSnippet(themeScope)}</CodeBlock>

Sous le capot, `Theme` est un `InheritedWidget` et lorsque les widgets recherchent le `Theme`, ils obtiennent le `Theme` du widget `Theme` le plus proche au-dessus d'eux dans l'arbre des widgets.

<<<<<<< HEAD
Riverpod fonctionne différemment, puisque tout l'état de votre application est généralement stocké dans un widget racine [ProviderScope]. 
Ne vous inquiétez pas, cela n'entraîne pas la reconstruction de toute votre application lorsque l'état change, cela vous permet simplement d'accéder à l'état à partir de n'importe quel endroit de votre arborescence de widgets.

Que faire si vous voulez des providers différents selon la page dans laquelle vous vous trouvez ? 

La première chose à considérer est de savoir si le comportement du provider sera différent d'une manière ou d'une autre.

Si c'est le cas -> créez simplement un nouveau provider avec un nom différent et utilisez-le dans cette page.

Si non -> Pensez à utiliser une famille [En savoir plus sur les familles ici](/docs/concepts/modifiers/family). 

Souvent, vous commencez par penser que vous n'avez besoin d'un "provider" que sur une page particulière, mais vous finissez par vouloir l'utiliser dans une autre page par la suite. 
Les familles vous protègent contre cette éventualité, et sont une différence majeure dans la façon dont vous devez ajuster votre pensée si vous venez de `package:provider`.
=======
Riverpod fonctionne différemment, puisque tout l'état de votre application est généralement stocké dans un widget [ProviderScope] racine. 
Ne vous inquiétez pas, cela n'entraîne pas la reconstruction de toute votre application lorsque l'état change, cela vous permet simplement d'accéder à l'état à partir de n'importe quel endroit de votre arbre de widgets.

Que faire si vous voulez des providers différents selon la page dans laquelle vous vous trouvez ? 

La première chose à considérer est de savoir si le comportement fourni sera différent de quelque manière que ce soit.

Si oui -> créez simplement un nouveau provider avec un nom différent et utilisez-le dans cette page.

Sinon -> Envisagez d'utiliser une famille [Pour en savoir plus sur les familles, cliquez ici](/docs/concepts/modifiers/family). 

Souvent, vous commencez par penser que vous n'avez besoin d'un provider que sur une page particulière, mais vous finissez par vouloir l'utiliser dans une autre page par la suite. 
Les familles vous protègent contre cette éventualité, et sont une différence majeure dans la façon dont vous devriez ajuster votre pensée si vous venez de `package:provider`.
>>>>>>> 01f66c936e312493a4bf6ef40a9254827c7eed99

Si les familles ne correspondent vraiment pas à votre cas d'utilisation, l'exemple suivant vous montre comment remplacer un provider pour un sous-arbre particulier.

<CodeBlock>{trimSnippet(subtreeScope)}</CodeBlock>

<<<<<<< HEAD
## Quand choisir Provider Scope ou Family ?

S'il est important de comprendre le fonctionnement d'une lunette, il est facile de s'emballer lorsqu'on l'utilise.
=======
## Quand choisir des Providers ou des familles délimités (Scoped) ?

Bien qu'il soit important de comprendre les scopes, il est facile de se laisser emporter par leur utilisation.
>>>>>>> 01f66c936e312493a4bf6ef40a9254827c7eed99

Si vous voulez une instance différente de l'état d'un provider selon l'endroit où il se trouve dans l'arbre des widgets, vous avez quelques alternatives à votre disposition : `Scoping`, `Families`, ou une combinaison.
Le choix approprié dépend de votre cas d'utilisation.

<<<<<<< HEAD
Family:
- Pro: Vous pouvez afficher plusieurs états, quel que soit le sous-arbre dans lequel vous vous trouvez.
- Pro: Cela en fait une solution plus souple et plus évolutive pour de nombreux cas d'utilisation.

Scoping:
- Con: Vous vous retrouvez avec plus d'imbrications de widgets [ProviderScope] dans votre arbre de widgets.
- Con: Vous ne pouvez accéder qu'à une seule override dans votre section de l'arbre des widgets. 
- Con: Vous finissez par devoir lister explicitement les dépendances de la plupart de vos providers.
- Pro: Vous pouvez réduire le nombre de paramètres dans les constructeurs de vos widgets.
- Pro: Vous obtenez un léger avantage en termes de performances, et vous pouvez potentiellement rendre certains de vos constructeurs de widgets `const`.

En combinant les deux approches, vous pouvez bénéficier des avantages des deux approches, mais vous devez toujours faire face aux inconvénients du cadrage.

:::warning
Rappelez-vous que les scopes introduisent une nouvelle instance de l'état de chaque provider qui est surchargé ou qui a listé une dépendance sur un provider qui a été surchargé.If you override with the same parameter in a different subtree of the app, it will **not** be the same instance of the provider's state. 
Les familles sont plus flexibles en général, et avec la prochaine fonction de génération de code, il est facile d'utiliser plusieurs paramètres pour une famille.
Une bonne combinaison consiste souvent à utiliser à la fois les familles et le scoping. Utilisez une famille pour fournir un accès général à une partie de l'état n'importe où dans votre application, puis utilisez le scoping 
=======
Familles :
- Pro : Vous pouvez afficher plusieurs états, quel que soit le sous-arbre dans lequel vous vous trouvez.
- Pro : Cela en fait une solution plus flexible et évolutive pour de nombreux cas d'utilisation.

Scoping :
- Contre : Vous vous retrouvez avec plus d'imbrication de widgets [ProviderScope] dans votre arbre de widgets.
- Contre : Vous ne pouvez accéder qu'à une seule surcharge dans votre section de l'arbre des widgets. 
- Contre : vous finissez par devoir lister explicitement les dépendances de la plupart de vos providers.
- Pour : Vous pouvez réduire le nombre de paramètres dans les constructeurs de vos widgets
- Pour : Vous obtenez un léger avantage en termes de performances, et vous pouvez potentiellement rendre certains de vos constructeurs de widgets `const`.

En utilisant une combinaison des deux approches, vous pouvez obtenir les avantages des deux approches, mais vous devez toujours faire face aux inconvénients du scoping.

:::warning
Rappelez-vous que les scopes introduisent une nouvelle instance de l'état de chaque provider qui est surchargé ou qui a listé une dépendance sur un provider qui a été surchargé.
Si vous surchargez avec le même paramètre dans un sous-arbre différent de l'application, ce ne sera **pas** la même instance de l'état du provider. 
Les familles sont plus flexibles en général, et avec la prochaine fonctionnalité de génération de code, il est facile d'utiliser plusieurs paramètres pour une famille.
Une bonne combinaison consiste souvent à utiliser à la fois les familles et le scoping. Utilisez une famille pour fournir un accès général à un élément d'état n'importe où dans votre application, puis utilisez le scoping pour
>>>>>>> 01f66c936e312493a4bf6ef40a9254827c7eed99
pour fournir une instance spécifique de l'état de la famille en fonction de l'endroit où vous vous trouvez dans l'arbre des widgets.
:::

### Utilisations moins courantes des Scopes

Il peut arriver que vous souhaitiez remplacer un ensemble de providers dans un sous-arbre spécifique de votre application. 
<<<<<<< HEAD

En listant un provider commun dans la liste des dépendances de chacun de ces providers, 
vous pouvez facilement créer de nouveaux états pour tous ces providers en même temps, en surchargeant le provider commun.

Notez que si vous essayez d'utiliser des familles pour cela, vous vous retrouverez avec de nombreuses familles qui ont toutes le même paramètre, 
et vous pourriez finir par passer ce paramètre dans toute l'arborescence du widget.
=======
En listant un provider commun dans la liste des dépendances de chacun de ces providers, vous pouvez facilement créer de nouveaux états pour tous ces providers en même temps, en surchargeant le provider commun.

Notez que si vous essayez d'utiliser des familles pour cela, vous vous retrouverez avec de nombreuses familles qui ont toutes le même paramètre, et vous pourriez finir par passer ce paramètre partout dans l'arbre des widgets.
>>>>>>> 01f66c936e312493a4bf6ef40a9254827c7eed99
Dans ce cas, il est également acceptable d'utiliser des scopes.

:::warning
Une fois que vous commencez à utiliser scope, assurez-vous de toujours lister vos dépendances et de les maintenir à jour, pour éviter les exceptions d'exécution.
Pour vous aider, nous avons créé [riverpod_lint] qui vous avertira si une dépendance est manquante.
De plus, avec [riverpod_generator], le générateur de code génère automatiquement la liste des dépendances.
:::

[ProviderContainer]: https://pub.dev/documentation/riverpod/latest/riverpod/ProviderContainer-class.html
[ProviderScope]: https://pub.dev/documentation/flutter_riverpod/latest/flutter_riverpod/ProviderScope-class.html
[riverpod_lint]: https://github.com/rrousselGit/riverpod/tree/master/packages/riverpod_lint
[riverpod_generator]: https://github.com/rrousselGit/riverpod/tree/master/packages/riverpod_generator
